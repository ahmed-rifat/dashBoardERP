"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsvectormap";
exports.ids = ["vendor-chunks/jsvectormap"];
exports.modules = {

/***/ "(ssr)/./node_modules/jsvectormap/dist/jsvectormap.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/jsvectormap/dist/jsvectormap.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/**\n * By https://github.com/TehShrike/deepmerge\n */\n\nvar isMergeableObject = function isMergeableObject(value) {\n  return isNonNullObject(value) && !isSpecial(value);\n};\nfunction isNonNullObject(value) {\n  return !!value && typeof value === 'object';\n}\nfunction isSpecial(value) {\n  var stringValue = Object.prototype.toString.call(value);\n  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isNode(value) || isReactElement(value);\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\nfunction isReactElement(value) {\n  return value.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isNode(value) {\n  return value instanceof Node;\n}\nfunction emptyTarget(val) {\n  return Array.isArray(val) ? [] : {};\n}\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n}\nfunction defaultArrayMerge(target, source, options) {\n  return target.concat(source).map(function (element) {\n    return cloneUnlessOtherwiseSpecified(element, options);\n  });\n}\nfunction getMergeFunction(key, options) {\n  if (!options.customMerge) {\n    return deepmerge;\n  }\n  var customMerge = options.customMerge(key);\n  return typeof customMerge === 'function' ? customMerge : deepmerge;\n}\nfunction getEnumerableOwnPropertySymbols(target) {\n  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n    return target.propertyIsEnumerable(symbol);\n  }) : [];\n}\nfunction getKeys(target) {\n  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n}\nfunction propertyIsOnObject(object, property) {\n  try {\n    return property in object;\n  } catch (_) {\n    return false;\n  }\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n  return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n  && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n  && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n}\nfunction mergeObject(target, source, options) {\n  var destination = {};\n  if (options.isMergeableObject(target)) {\n    getKeys(target).forEach(function (key) {\n      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n    });\n  }\n  getKeys(source).forEach(function (key) {\n    if (propertyIsUnsafe(target, key)) {\n      return;\n    }\n    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n    } else {\n      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n    }\n  });\n  return destination;\n}\nvar deepmerge = function deepmerge(target, source, options) {\n  options = options || {};\n  options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n  options.isMergeableObject = options.isMergeableObject || isMergeableObject;\n  // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n  // implementations can use it. The caller may not replace it.\n  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n  var sourceIsArray = Array.isArray(source);\n  var targetIsArray = Array.isArray(target);\n  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n  if (!sourceAndTargetTypesMatch) {\n    return cloneUnlessOtherwiseSpecified(source, options);\n  } else if (sourceIsArray) {\n    return options.arrayMerge(target, source, options);\n  } else {\n    return mergeObject(target, source, options);\n  }\n};\n\n/**\n * --------------------------------------------------------------------------\n * Public Util Api\n * --------------------------------------------------------------------------\n */\nvar getElement = function getElement(selector) {\n  if (typeof selector === 'object' && typeof selector.nodeType !== 'undefined') {\n    return selector;\n  }\n  if (typeof selector === 'string') {\n    return document.querySelector(selector);\n  }\n  return null;\n};\nvar createElement = function createElement(type, classes, content, html) {\n  if (html === void 0) {\n    html = false;\n  }\n  var el = document.createElement(type);\n  if (content) {\n    el[!html ? 'textContent' : 'innerHTML'] = content;\n  }\n  if (classes) {\n    el.className = classes;\n  }\n  return el;\n};\nvar findElement = function findElement(parentElement, selector) {\n  return Element.prototype.querySelector.call(parentElement, selector);\n};\nvar removeElement = function removeElement(target) {\n  target.parentNode.removeChild(target);\n};\nvar isImageUrl = function isImageUrl(url) {\n  return /\\.(jpg|gif|png)$/.test(url);\n};\nvar hyphenate = function hyphenate(string) {\n  return string.replace(/[\\w]([A-Z])/g, function (m) {\n    return m[0] + \"-\" + m[1];\n  }).toLowerCase();\n};\nvar merge = function merge(target, source, deep) {\n  if (deep === void 0) {\n    deep = false;\n  }\n  if (deep) {\n    return deepmerge(target, source);\n  }\n  return Object.assign(target, source);\n};\nvar getLineUid = function getLineUid(from, to) {\n  return from.toLowerCase() + \":to:\" + to.toLowerCase();\n};\nvar inherit = function inherit(target, source) {\n  Object.assign(target.prototype, source);\n};\n\nvar eventRegistry = {};\nvar eventUid = 1;\n\n/**\n * ------------------------------------------------------------------------\n * Event Handler\n * ------------------------------------------------------------------------\n */\nvar EventHandler = {\n  on: function on(element, event, handler, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var uid = \"jvm:\" + event + \"::\" + eventUid++;\n    eventRegistry[uid] = {\n      selector: element,\n      handler: handler\n    };\n    handler._uid = uid;\n    element.addEventListener(event, handler, options);\n  },\n  delegate: function delegate(element, event, selector, handler) {\n    event = event.split(' ');\n    event.forEach(function (eventName) {\n      EventHandler.on(element, eventName, function (e) {\n        var target = e.target;\n        if (target.matches(selector)) {\n          handler.call(target, e);\n        }\n      });\n    });\n  },\n  off: function off(element, event, handler) {\n    var eventType = event.split(':')[1];\n    element.removeEventListener(eventType, handler);\n    delete eventRegistry[handler._uid];\n  },\n  flush: function flush() {\n    Object.keys(eventRegistry).forEach(function (event) {\n      EventHandler.off(eventRegistry[event].selector, event, eventRegistry[event].handler);\n    });\n  },\n  getEventRegistry: function getEventRegistry() {\n    return eventRegistry;\n  }\n};\n\nfunction setupContainerEvents() {\n  var _this = this;\n  var map = this;\n  var mouseDown = false;\n  var oldPageX;\n  var oldPageY;\n  if (this.params.draggable) {\n    EventHandler.on(this.container, 'mousemove', function (e) {\n      if (!mouseDown) {\n        return false;\n      }\n      map.transX -= (oldPageX - e.pageX) / map.scale;\n      map.transY -= (oldPageY - e.pageY) / map.scale;\n      map._applyTransform();\n      oldPageX = e.pageX;\n      oldPageY = e.pageY;\n    });\n    EventHandler.on(this.container, 'mousedown', function (e) {\n      mouseDown = true;\n      oldPageX = e.pageX;\n      oldPageY = e.pageY;\n      return false;\n    });\n    EventHandler.on(document.body, 'mouseup', function () {\n      mouseDown = false;\n    });\n  }\n  if (this.params.zoomOnScroll) {\n    EventHandler.on(this.container, 'wheel', function (event) {\n      var deltaY = ((event.deltaY || -event.wheelDelta || event.detail) >> 10 || 1) * 75;\n      var rect = _this.container.getBoundingClientRect();\n      var offsetX = event.pageX - rect.left - window.pageXOffset;\n      var offsetY = event.pageY - rect.top - window.pageYOffset;\n      var zoomStep = Math.pow(1 + map.params.zoomOnScrollSpeed / 1000, -1.5 * deltaY);\n      if (map.tooltip) {\n        map._tooltip.hide();\n      }\n      map._setScale(map.scale * zoomStep, offsetX, offsetY);\n      event.preventDefault();\n    });\n  }\n}\n\nvar Events = {\n  onLoaded: 'map:loaded',\n  onViewportChange: 'viewport:changed',\n  onRegionClick: 'region:clicked',\n  onMarkerClick: 'marker:clicked',\n  onRegionSelected: 'region:selected',\n  onMarkerSelected: 'marker:selected',\n  onRegionTooltipShow: 'region.tooltip:show',\n  onMarkerTooltipShow: 'marker.tooltip:show',\n  onDestroyed: 'map:destroyed'\n};\n\nvar parseEvent = function parseEvent(map, selector, isTooltip) {\n  var element = getElement(selector);\n  var type = element.getAttribute('class').indexOf('jvm-region') === -1 ? 'marker' : 'region';\n  var isRegion = type === 'region';\n  var code = isRegion ? element.getAttribute('data-code') : element.getAttribute('data-index');\n  var event = isRegion ? Events.onRegionSelected : Events.onMarkerSelected;\n\n  // Init tooltip event\n  if (isTooltip) {\n    event = isRegion ? Events.onRegionTooltipShow : Events.onMarkerTooltipShow;\n  }\n  return {\n    type: type,\n    code: code,\n    event: event,\n    element: isRegion ? map.regions[code].element : map._markers[code].element,\n    tooltipText: isRegion ? map._mapData.paths[code].name || '' : map._markers[code].config.name || ''\n  };\n};\nfunction setupElementEvents() {\n  var map = this;\n  var container = this.container;\n  var pageX, pageY, mouseMoved;\n  EventHandler.on(container, 'mousemove', function (event) {\n    if (Math.abs(pageX - event.pageX) + Math.abs(pageY - event.pageY) > 2) {\n      mouseMoved = true;\n    }\n  });\n\n  // When the mouse is pressed\n  EventHandler.delegate(container, 'mousedown', '.jvm-element', function (event) {\n    pageX = event.pageX;\n    pageY = event.pageY;\n    mouseMoved = false;\n  });\n\n  // When the mouse is over the region/marker | When the mouse is out the region/marker\n  EventHandler.delegate(container, 'mouseover mouseout', '.jvm-element', function (event) {\n    var data = parseEvent(map, this, true);\n    var showTooltip = map.params.showTooltip;\n    if (event.type === 'mouseover') {\n      data.element.hover(true);\n      if (showTooltip) {\n        map._tooltip.text(data.tooltipText);\n        map._tooltip.show();\n        map._emit(data.event, [event, map._tooltip, data.code]);\n      }\n    } else {\n      data.element.hover(false);\n      if (showTooltip) {\n        map._tooltip.hide();\n      }\n    }\n  });\n\n  // When the click is released\n  EventHandler.delegate(container, 'mouseup', '.jvm-element', function (event) {\n    var data = parseEvent(map, this);\n    if (mouseMoved) {\n      return;\n    }\n    if (data.type === 'region' && map.params.regionsSelectable || data.type === 'marker' && map.params.markersSelectable) {\n      var element = data.element;\n\n      // We're checking if regions/markers|SelectableOne option is presented\n      if (map.params[data.type + \"sSelectableOne\"]) {\n        map._clearSelected(data.type + \"s\");\n      }\n      if (data.element.isSelected) {\n        element.select(false);\n      } else {\n        element.select(true);\n      }\n      map._emit(data.event, [data.code, element.isSelected, map._getSelected(data.type + \"s\")]);\n    }\n  });\n\n  // When region/marker is clicked\n  EventHandler.delegate(container, 'click', '.jvm-element', function (event) {\n    var _parseEvent = parseEvent(map, this),\n      type = _parseEvent.type,\n      code = _parseEvent.code;\n    map._emit(type === 'region' ? Events.onRegionClick : Events.onMarkerClick, [event, code]);\n  });\n}\n\nfunction setupZoomButtons() {\n  var _this = this;\n  var zoomin = createElement('div', 'jvm-zoom-btn jvm-zoomin', '&#43;', true);\n  var zoomout = createElement('div', 'jvm-zoom-btn jvm-zoomout', '&#x2212', true);\n  this.container.appendChild(zoomin);\n  this.container.appendChild(zoomout);\n  var handler = function handler(zoomin) {\n    if (zoomin === void 0) {\n      zoomin = true;\n    }\n    return function () {\n      return _this._setScale(zoomin ? _this.scale * _this.params.zoomStep : _this.scale / _this.params.zoomStep, _this._width / 2, _this._height / 2, false, _this.params.zoomAnimate);\n    };\n  };\n  EventHandler.on(zoomin, 'click', handler());\n  EventHandler.on(zoomout, 'click', handler(false));\n}\n\nfunction setupContainerTouchEvents() {\n  var map = this,\n    touchStartScale,\n    touchStartDistance,\n    touchX,\n    touchY,\n    centerTouchX,\n    centerTouchY,\n    lastTouchesLength;\n  var handleTouchEvent = function handleTouchEvent(e) {\n    var touches = e.touches;\n    var offset, scale, transXOld, transYOld;\n    if (e.type == 'touchstart') {\n      lastTouchesLength = 0;\n    }\n    if (touches.length == 1) {\n      if (lastTouchesLength == 1) {\n        transXOld = map.transX;\n        transYOld = map.transY;\n        map.transX -= (touchX - touches[0].pageX) / map.scale;\n        map.transY -= (touchY - touches[0].pageY) / map.scale;\n        map._tooltip.hide();\n        map._applyTransform();\n        if (transXOld != map.transX || transYOld != map.transY) {\n          e.preventDefault();\n        }\n      }\n      touchX = touches[0].pageX;\n      touchY = touches[0].pageY;\n    } else if (touches.length == 2) {\n      if (lastTouchesLength == 2) {\n        scale = Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2)) / touchStartDistance;\n        map._setScale(touchStartScale * scale, centerTouchX, centerTouchY);\n        map._tooltip.hide();\n        e.preventDefault();\n      } else {\n        var rect = map.container.getBoundingClientRect();\n        offset = {\n          top: rect.top + window.scrollY,\n          left: rect.left + window.scrollX\n        };\n        if (touches[0].pageX > touches[1].pageX) {\n          centerTouchX = touches[1].pageX + (touches[0].pageX - touches[1].pageX) / 2;\n        } else {\n          centerTouchX = touches[0].pageX + (touches[1].pageX - touches[0].pageX) / 2;\n        }\n        if (touches[0].pageY > touches[1].pageY) {\n          centerTouchY = touches[1].pageY + (touches[0].pageY - touches[1].pageY) / 2;\n        } else {\n          centerTouchY = touches[0].pageY + (touches[1].pageY - touches[0].pageY) / 2;\n        }\n        centerTouchX -= offset.left;\n        centerTouchY -= offset.top;\n        touchStartScale = map.scale;\n        touchStartDistance = Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2));\n      }\n    }\n    lastTouchesLength = touches.length;\n  };\n  EventHandler.on(map.container, 'touchstart', handleTouchEvent);\n  EventHandler.on(map.container, 'touchmove', handleTouchEvent);\n}\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _createForOfIteratorHelperLoose(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (t) return (t = t.call(r)).next.bind(t);\n  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n    t && (r = t);\n    var o = 0;\n    return function () {\n      return o >= r.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: r[o++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nfunction _inheritsLoose(t, o) {\n  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar BaseComponent = /*#__PURE__*/function () {\n  function BaseComponent() {}\n  var _proto = BaseComponent.prototype;\n  _proto.dispose = function dispose() {\n    if (this._tooltip) {\n      removeElement(this._tooltip);\n    } else {\n      // @todo: move shape in base component in v2\n      this.shape.remove();\n    }\n    for (var _iterator = _createForOfIteratorHelperLoose(Object.getOwnPropertyNames(this)), _step; !(_step = _iterator()).done;) {\n      var propertyName = _step.value;\n      this[propertyName] = null;\n    }\n  };\n  return BaseComponent;\n}();\n\n/**\n * ------------------------------------------------------------------------\n * Interactable\n * ------------------------------------------------------------------------\n */\nvar Interactable = {\n  getLabelText: function getLabelText(key, label) {\n    if (!label) {\n      return;\n    }\n    if (typeof label.render === 'function') {\n      var params = [];\n\n      // Pass additional paramater (Marker config object) in case it's a Marker.\n      if (this.config && this.config.marker) {\n        params.push(this.config.marker);\n      }\n\n      // Becuase we need to add the key always at the end\n      params.push(key);\n      return label.render.apply(this, params);\n    }\n    return key;\n  },\n  getLabelOffsets: function getLabelOffsets(key, label) {\n    if (typeof label.offsets === 'function') {\n      return label.offsets(key);\n    }\n\n    // If offsets are an array of offsets e.g offsets: [ [0, 25], [10, 15] ]\n    if (Array.isArray(label.offsets)) {\n      return label.offsets[key];\n    }\n    return [0, 0];\n  },\n  setStyle: function setStyle(property, value) {\n    this.shape.setStyle(property, value);\n  },\n  remove: function remove() {\n    this.shape.remove();\n    if (this.label) this.label.remove();\n  },\n  hover: function hover(state) {\n    this._setStatus('isHovered', state);\n  },\n  select: function select(state) {\n    this._setStatus('isSelected', state);\n  },\n  // Private\n  _setStatus: function _setStatus(property, state) {\n    this.shape[property] = state;\n    this.shape.updateStyle();\n    this[property] = state;\n    if (this.label) {\n      this.label[property] = state;\n      this.label.updateStyle();\n    }\n  }\n};\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar Region = /*#__PURE__*/function (_BaseComponent) {\n  function Region(_ref) {\n    var _this;\n    var map = _ref.map,\n      code = _ref.code,\n      path = _ref.path,\n      style = _ref.style,\n      label = _ref.label,\n      labelStyle = _ref.labelStyle,\n      labelsGroup = _ref.labelsGroup;\n    _this = _BaseComponent.call(this) || this;\n    _this._map = map;\n    _this.shape = _this._createRegion(path, code, style);\n    var text = _this.getLabelText(code, label);\n\n    // If label is passed and render function returns something \n    if (label && text) {\n      var bbox = _this.shape.getBBox();\n      var offsets = _this.getLabelOffsets(code, label);\n      _this.labelX = bbox.x + bbox.width / 2 + offsets[0];\n      _this.labelY = bbox.y + bbox.height / 2 + offsets[1];\n      _this.label = _this._map.canvas.createText({\n        text: text,\n        textAnchor: 'middle',\n        alignmentBaseline: 'central',\n        dataCode: code,\n        x: _this.labelX,\n        y: _this.labelY\n      }, labelStyle, labelsGroup);\n      _this.label.addClass('jvm-region jvm-element');\n    }\n    return _this;\n  }\n  _inheritsLoose(Region, _BaseComponent);\n  var _proto = Region.prototype;\n  _proto._createRegion = function _createRegion(path, code, style) {\n    path = this._map.canvas.createPath({\n      d: path,\n      dataCode: code\n    }, style);\n    path.addClass('jvm-region jvm-element');\n    return path;\n  };\n  _proto.updateLabelPosition = function updateLabelPosition() {\n    if (this.label) {\n      this.label.set({\n        x: this.labelX * this._map.scale + this._map.transX * this._map.scale,\n        y: this.labelY * this._map.scale + this._map.transY * this._map.scale\n      });\n    }\n  };\n  return Region;\n}(BaseComponent);\ninherit(Region, Interactable);\n\nfunction createRegions() {\n  this._regionLabelsGroup = this._regionLabelsGroup || this.canvas.createGroup('jvm-regions-labels-group');\n  for (var code in this._mapData.paths) {\n    var region = new Region({\n      map: this,\n      code: code,\n      path: this._mapData.paths[code].path,\n      style: merge({}, this.params.regionStyle),\n      labelStyle: this.params.regionLabelStyle,\n      labelsGroup: this._regionLabelsGroup,\n      label: this.params.labels && this.params.labels.regions\n    });\n    this.regions[code] = {\n      config: this._mapData.paths[code],\n      element: region\n    };\n  }\n}\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar Line = /*#__PURE__*/function (_BaseComponent) {\n  function Line(_ref) {\n    var _this;\n    var index = _ref.index,\n      map = _ref.map,\n      style = _ref.style,\n      x1 = _ref.x1,\n      y1 = _ref.y1,\n      x2 = _ref.x2,\n      y2 = _ref.y2,\n      group = _ref.group,\n      config = _ref.config;\n    _this = _BaseComponent.call(this) || this;\n    _this.config = config;\n    _this.shape = map.canvas.createLine({\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      dataIndex: index\n    }, style, group);\n    _this.shape.addClass('jvm-line');\n    return _this;\n  }\n  _inheritsLoose(Line, _BaseComponent);\n  var _proto = Line.prototype;\n  _proto.setStyle = function setStyle(property, value) {\n    this.shape.setStyle(property, value);\n  };\n  return Line;\n}(BaseComponent);\n\nfunction createLines(lines, markers, isRecentlyCreated) {\n  if (isRecentlyCreated === void 0) {\n    isRecentlyCreated = false;\n  }\n  var point1 = false,\n    point2 = false;\n\n  // Create group for holding lines\n  // we're checking if `linesGroup` exists or not becuase we may add lines\n  // after the map has loaded so we will append the futured lines to this group as well.\n  this.linesGroup = this.linesGroup || this.canvas.createGroup('jvm-lines-group');\n  for (var index in lines) {\n    var config = lines[index];\n    for (var mindex in markers) {\n      var markerConfig = isRecentlyCreated ? markers[mindex].config : markers[mindex];\n      if (markerConfig.name === config.from) {\n        point1 = this.getMarkerPosition(markerConfig);\n      }\n      if (markerConfig.name === config.to) {\n        point2 = this.getMarkerPosition(markerConfig);\n      }\n    }\n    if (point1 !== false && point2 !== false) {\n      // Register lines with unique keys\n      this._lines[getLineUid(config.from, config.to)] = new Line({\n        index: index,\n        map: this,\n        // Merge the default `lineStyle` object with the custom `line` config style\n        style: merge({\n          initial: this.params.lineStyle\n        }, {\n          initial: config.style || {}\n        }, true),\n        x1: point1.x,\n        y1: point1.y,\n        x2: point2.x,\n        y2: point2.y,\n        group: this.linesGroup,\n        config: config\n      });\n    }\n  }\n}\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar Marker = /*#__PURE__*/function (_BaseComponent) {\n  function Marker(_ref) {\n    var _this;\n    var index = _ref.index,\n      style = _ref.style,\n      label = _ref.label,\n      cx = _ref.cx,\n      cy = _ref.cy,\n      map = _ref.map,\n      group = _ref.group;\n    _this = _BaseComponent.call(this) || this;\n\n    // Private\n    _this._map = map;\n    _this._isImage = !!style.initial.image;\n\n    // Protected\n    _this.config = arguments[0];\n    _this.shape = map.canvas[_this._isImage ? 'createImage' : 'createCircle']({\n      dataIndex: index,\n      cx: cx,\n      cy: cy\n    }, style, group);\n    _this.shape.addClass('jvm-marker jvm-element');\n    if (_this._isImage) {\n      _this.updateLabelPosition();\n    }\n    if (label) {\n      _this._createLabel(_this.config);\n    }\n    return _this;\n  }\n  _inheritsLoose(Marker, _BaseComponent);\n  var _proto = Marker.prototype;\n  _proto.updateLabelPosition = function updateLabelPosition() {\n    if (this.label) {\n      this.label.set({\n        x: this._labelX * this._map.scale + this._offsets[0] + this._map.transX * this._map.scale + 5 + (this._isImage ? (this.shape.width || 0) / 2 : this.shape.node.r.baseVal.value),\n        y: this._labelY * this._map.scale + this._map.transY * this._map.scale + this._offsets[1]\n      });\n    }\n  };\n  _proto._createLabel = function _createLabel(_ref2) {\n    var index = _ref2.index,\n      map = _ref2.map,\n      label = _ref2.label,\n      labelsGroup = _ref2.labelsGroup,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      marker = _ref2.marker,\n      isRecentlyCreated = _ref2.isRecentlyCreated;\n    var labelText = this.getLabelText(index, label);\n    this._labelX = cx / map.scale - map.transX;\n    this._labelY = cy / map.scale - map.transY;\n    this._offsets = isRecentlyCreated && marker.offsets ? marker.offsets : this.getLabelOffsets(index, label);\n    this.label = map.canvas.createText({\n      text: labelText,\n      dataIndex: index,\n      x: this._labelX,\n      y: this._labelY,\n      dy: '0.6ex'\n    }, map.params.markerLabelStyle, labelsGroup);\n    this.label.addClass('jvm-marker jvm-element');\n    if (isRecentlyCreated) {\n      this.updateLabelPosition();\n    }\n  };\n  return Marker;\n}(BaseComponent);\ninherit(Marker, Interactable);\n\nfunction createMarkers(markers, isRecentlyCreated) {\n  var _this = this;\n  if (markers === void 0) {\n    markers = {};\n  }\n  if (isRecentlyCreated === void 0) {\n    isRecentlyCreated = false;\n  }\n  // Create groups for holding markers and markers labels\n  // We're checking if `markersGroup` exists or not becuase we may add markers after the map has loaded\n  // So we will append the futured markers to this group as well.\n  this._markersGroup = this._markersGroup || this.canvas.createGroup('jvm-markers-group');\n  this._markerLabelsGroup = this._markerLabelsGroup || this.canvas.createGroup('jvm-markers-labels-group');\n  var _loop = function _loop() {\n      var config = markers[index];\n      var point = _this.getMarkerPosition(config);\n      var uid = config.coords.join(':');\n      if (!point) {\n        return 0; // continue\n      }\n\n      // We're checking if recently created marker does already exist\n      // If it does we don't need to create it again, so we'll continue\n      // Becuase we may have more than one marker submitted via `addMarkers` method.\n      if (isRecentlyCreated) {\n        if (Object.keys(_this._markers).filter(function (i) {\n          return _this._markers[i]._uid === uid;\n        }).length) {\n          return 0; // continue\n        }\n        index = Object.keys(_this._markers).length;\n      }\n      var marker = new Marker({\n        index: index,\n        map: _this,\n        // Merge the `markerStyle` object with the marker config `style` if presented.\n        style: merge(_this.params.markerStyle, _extends({}, config.style || {}), true),\n        label: _this.params.labels && _this.params.labels.markers,\n        labelsGroup: _this._markerLabelsGroup,\n        cx: point.x,\n        cy: point.y,\n        group: _this._markersGroup,\n        marker: config,\n        isRecentlyCreated: isRecentlyCreated\n      });\n\n      // Check for marker duplication\n      // this is useful when for example: a user clicks a button for creating marker two times\n      // so it will remove the old one and the new one will take its place.\n      if (_this._markers[index]) {\n        _this.removeMarkers([index]);\n      }\n      _this._markers[index] = {\n        _uid: uid,\n        config: config,\n        element: marker\n      };\n    },\n    _ret;\n  for (var index in markers) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n  }\n}\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar Legend = /*#__PURE__*/function () {\n  function Legend(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this._options = options;\n    this._map = this._options.map;\n    this._series = this._options.series;\n    this._body = createElement('div', 'jvm-legend');\n    if (this._options.cssClass) {\n      this._body.setAttribute('class', this._options.cssClass);\n    }\n    if (options.vertical) {\n      this._map.legendVertical.appendChild(this._body);\n    } else {\n      this._map.legendHorizontal.appendChild(this._body);\n    }\n    this.render();\n  }\n  var _proto = Legend.prototype;\n  _proto.render = function render() {\n    var ticks = this._series.scale.getTicks();\n    var inner = createElement('div', 'jvm-legend-inner');\n    this._body.innderHTML = '';\n    if (this._options.title) {\n      var legendTitle = createElement('div', 'jvm-legend-title', this._options.title);\n      this._body.appendChild(legendTitle);\n    }\n    this._body.appendChild(inner);\n    for (var i = 0; i < ticks.length; i++) {\n      var tick = createElement('div', 'jvm-legend-tick');\n      var sample = createElement('div', 'jvm-legend-tick-sample');\n      switch (this._series.config.attribute) {\n        case 'fill':\n          if (isImageUrl(ticks[i].value)) {\n            sample.style.background = \"url(\" + ticks[i].value + \")\";\n          } else {\n            sample.style.background = ticks[i].value;\n          }\n          break;\n        case 'stroke':\n          sample.style.background = ticks[i].value;\n          break;\n        case 'image':\n          sample.style.background = \"url(\" + (typeof ticks[i].value === 'object' ? ticks[i].value.url : ticks[i].value) + \") no-repeat center center\";\n          sample.style.backgroundSize = 'cover';\n          break;\n      }\n      tick.appendChild(sample);\n      var label = ticks[i].label;\n      if (this._options.labelRender) {\n        label = this._options.labelRender(label);\n      }\n      var tickText = createElement('div', 'jvm-legend-tick-text', label);\n      tick.appendChild(tickText);\n      inner.appendChild(tick);\n    }\n  };\n  return Legend;\n}();\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar OrdinalScale = /*#__PURE__*/function () {\n  function OrdinalScale(scale) {\n    this._scale = scale;\n  }\n  var _proto = OrdinalScale.prototype;\n  _proto.getValue = function getValue(value) {\n    return this._scale[value];\n  };\n  _proto.getTicks = function getTicks() {\n    var ticks = [];\n    for (var key in this._scale) {\n      ticks.push({\n        label: key,\n        value: this._scale[key]\n      });\n    }\n    return ticks;\n  };\n  return OrdinalScale;\n}();\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar Series = /*#__PURE__*/function () {\n  function Series(config, elements, map) {\n    if (config === void 0) {\n      config = {};\n    }\n    // Private\n    this._map = map;\n    this._elements = elements; // Could be markers or regions\n    this._values = config.values || {};\n\n    // Protected\n    this.config = config;\n    this.config.attribute = config.attribute || 'fill';\n\n    // Set initial attributes\n    if (config.attributes) {\n      this.setAttributes(config.attributes);\n    }\n    if (typeof config.scale === 'object') {\n      this.scale = new OrdinalScale(config.scale);\n    }\n    if (this.config.legend) {\n      this.legend = new Legend(merge({\n        map: this._map,\n        series: this\n      }, this.config.legend));\n    }\n    this.setValues(this._values);\n  }\n  var _proto = Series.prototype;\n  _proto.setValues = function setValues(values) {\n    var attrs = {};\n    for (var key in values) {\n      if (values[key]) {\n        attrs[key] = this.scale.getValue(values[key]);\n      }\n    }\n    this.setAttributes(attrs);\n  };\n  _proto.setAttributes = function setAttributes(attrs) {\n    for (var code in attrs) {\n      if (this._elements[code]) {\n        this._elements[code].element.setStyle(this.config.attribute, attrs[code]);\n      }\n    }\n  };\n  _proto.clear = function clear() {\n    var key,\n      attrs = {};\n    for (key in this._values) {\n      if (this._elements[key]) {\n        attrs[key] = this._elements[key].element.shape.style.initial[this.config.attribute];\n      }\n    }\n    this.setAttributes(attrs);\n    this._values = {};\n  };\n  return Series;\n}();\n\nfunction createSeries() {\n  this.series = {\n    markers: [],\n    regions: []\n  };\n  for (var key in this.params.series) {\n    for (var i = 0; i < this.params.series[key].length; i++) {\n      this.series[key][i] = new Series(this.params.series[key][i], key === 'markers' ? this._markers : this.regions, this);\n    }\n  }\n}\n\nfunction applyTransform() {\n  var maxTransX, maxTransY, minTransX, minTransY;\n  if (this._defaultWidth * this.scale <= this._width) {\n    maxTransX = (this._width - this._defaultWidth * this.scale) / (2 * this.scale);\n    minTransX = (this._width - this._defaultWidth * this.scale) / (2 * this.scale);\n  } else {\n    maxTransX = 0;\n    minTransX = (this._width - this._defaultWidth * this.scale) / this.scale;\n  }\n  if (this._defaultHeight * this.scale <= this._height) {\n    maxTransY = (this._height - this._defaultHeight * this.scale) / (2 * this.scale);\n    minTransY = (this._height - this._defaultHeight * this.scale) / (2 * this.scale);\n  } else {\n    maxTransY = 0;\n    minTransY = (this._height - this._defaultHeight * this.scale) / this.scale;\n  }\n  if (this.transY > maxTransY) {\n    this.transY = maxTransY;\n  } else if (this.transY < minTransY) {\n    this.transY = minTransY;\n  }\n  if (this.transX > maxTransX) {\n    this.transX = maxTransX;\n  } else if (this.transX < minTransX) {\n    this.transX = minTransX;\n  }\n  this.canvas.applyTransformParams(this.scale, this.transX, this.transY);\n  if (this._markers) {\n    this._repositionMarkers();\n  }\n  if (this._lines) {\n    this._repositionLines();\n  }\n  this._repositionLabels();\n}\n\nfunction resize() {\n  var curBaseScale = this._baseScale;\n  if (this._width / this._height > this._defaultWidth / this._defaultHeight) {\n    this._baseScale = this._height / this._defaultHeight;\n    this._baseTransX = Math.abs(this._width - this._defaultWidth * this._baseScale) / (2 * this._baseScale);\n  } else {\n    this._baseScale = this._width / this._defaultWidth;\n    this._baseTransY = Math.abs(this._height - this._defaultHeight * this._baseScale) / (2 * this._baseScale);\n  }\n  this.scale *= this._baseScale / curBaseScale;\n  this.transX *= this._baseScale / curBaseScale;\n  this.transY *= this._baseScale / curBaseScale;\n}\n\nfunction setScale(scale, anchorX, anchorY, isCentered, animate) {\n  var _this = this;\n  var zoomStep,\n    interval,\n    i = 0,\n    count = Math.abs(Math.round((scale - this.scale) * 60 / Math.max(scale, this.scale))),\n    scaleStart,\n    scaleDiff,\n    transXStart,\n    transXDiff,\n    transYStart,\n    transYDiff,\n    transX,\n    transY;\n  if (scale > this.params.zoomMax * this._baseScale) {\n    scale = this.params.zoomMax * this._baseScale;\n  } else if (scale < this.params.zoomMin * this._baseScale) {\n    scale = this.params.zoomMin * this._baseScale;\n  }\n  if (typeof anchorX != 'undefined' && typeof anchorY != 'undefined') {\n    zoomStep = scale / this.scale;\n    if (isCentered) {\n      transX = anchorX + this._defaultWidth * (this._width / (this._defaultWidth * scale)) / 2;\n      transY = anchorY + this._defaultHeight * (this._height / (this._defaultHeight * scale)) / 2;\n    } else {\n      transX = this.transX - (zoomStep - 1) / scale * anchorX;\n      transY = this.transY - (zoomStep - 1) / scale * anchorY;\n    }\n  }\n  if (animate && count > 0) {\n    scaleStart = this.scale;\n    scaleDiff = (scale - scaleStart) / count;\n    transXStart = this.transX * this.scale;\n    transYStart = this.transY * this.scale;\n    transXDiff = (transX * scale - transXStart) / count;\n    transYDiff = (transY * scale - transYStart) / count;\n    interval = setInterval(function () {\n      i += 1;\n      _this.scale = scaleStart + scaleDiff * i;\n      _this.transX = (transXStart + transXDiff * i) / _this.scale;\n      _this.transY = (transYStart + transYDiff * i) / _this.scale;\n      _this._applyTransform();\n      if (i == count) {\n        clearInterval(interval);\n        _this._emit(Events.onViewportChange, [_this.scale, _this.transX, _this.transY]);\n      }\n    }, 10);\n  } else {\n    this.transX = transX;\n    this.transY = transY;\n    this.scale = scale;\n    this._applyTransform();\n    this._emit(Events.onViewportChange, [this.scale, this.transX, this.transY]);\n  }\n}\n\nfunction setFocus(config) {\n  var _this = this;\n  if (config === void 0) {\n    config = {};\n  }\n  var bbox,\n    codes = [];\n  if (config.region) {\n    codes.push(config.region);\n  } else if (config.regions) {\n    codes = config.regions;\n  }\n  if (codes.length) {\n    codes.forEach(function (code) {\n      if (_this.regions[code]) {\n        var itemBbox = _this.regions[code].element.shape.getBBox();\n        if (itemBbox) {\n          // Handle the first loop\n          if (typeof bbox == 'undefined') {\n            bbox = itemBbox;\n          } else {\n            // get the old bbox properties plus the current\n            // this kinda incrementing the old values and the new values\n            bbox = {\n              x: Math.min(bbox.x, itemBbox.x),\n              y: Math.min(bbox.y, itemBbox.y),\n              width: Math.max(bbox.x + bbox.width, itemBbox.x + itemBbox.width) - Math.min(bbox.x, itemBbox.x),\n              height: Math.max(bbox.y + bbox.height, itemBbox.y + itemBbox.height) - Math.min(bbox.y, itemBbox.y)\n            };\n          }\n        }\n      }\n    });\n    return this._setScale(Math.min(this._width / bbox.width, this._height / bbox.height), -(bbox.x + bbox.width / 2), -(bbox.y + bbox.height / 2), true, config.animate);\n  } else if (config.coords) {\n    var point = this.coordsToPoint(config.coords[0], config.coords[1]);\n    var x = this.transX - point.x / this.scale;\n    var y = this.transY - point.y / this.scale;\n    return this._setScale(config.scale * this._baseScale, x, y, true, config.animate);\n  }\n}\n\nfunction updateSize() {\n  this._width = this.container.offsetWidth;\n  this._height = this.container.offsetHeight;\n  this._resize();\n  this.canvas.setSize(this._width, this._height);\n  this._applyTransform();\n}\n\n/**\n * ------------------------------------------------------------------------\n * Object\n * ------------------------------------------------------------------------\n */\nvar Proj = {\n  /* sgn(n){\n    if (n > 0) {\n      return 1;\n    } else if (n < 0) {\n      return -1;\n    } else {\n      return n;\n    }\n  }, */\n  mill: function mill(lat, lng, c) {\n    return {\n      x: this.radius * (lng - c) * this.radDeg,\n      y: -this.radius * Math.log(Math.tan((45 + 0.4 * lat) * this.radDeg)) / 0.8\n    };\n  },\n  /* mill_inv(x, y, c) {\n    return {\n      lat: (2.5 * Math.atan(Math.exp(0.8 * y / this.radius)) - 5 * Math.PI / 8) * this.degRad,\n      lng: (c * this.radDeg + x / this.radius) * this.degRad\n    };\n  }, */\n  merc: function merc(lat, lng, c) {\n    return {\n      x: this.radius * (lng - c) * this.radDeg,\n      y: -this.radius * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))\n    };\n  },\n  /* merc_inv(x, y, c) {\n    return {\n      lat: (2 * Math.atan(Math.exp(y / this.radius)) - Math.PI / 2) * this.degRad,\n      lng: (c * this.radDeg + x / this.radius) * this.degRad\n    };\n  }, */\n  aea: function aea(lat, lng, c) {\n    var fi0 = 0,\n      lambda0 = c * this.radDeg,\n      fi1 = 29.5 * this.radDeg,\n      fi2 = 45.5 * this.radDeg,\n      fi = lat * this.radDeg,\n      lambda = lng * this.radDeg,\n      n = (Math.sin(fi1) + Math.sin(fi2)) / 2,\n      C = Math.cos(fi1) * Math.cos(fi1) + 2 * n * Math.sin(fi1),\n      theta = n * (lambda - lambda0),\n      ro = Math.sqrt(C - 2 * n * Math.sin(fi)) / n,\n      ro0 = Math.sqrt(C - 2 * n * Math.sin(fi0)) / n;\n    return {\n      x: ro * Math.sin(theta) * this.radius,\n      y: -(ro0 - ro * Math.cos(theta)) * this.radius\n    };\n  },\n  /* aea_inv(xCoord, yCoord, c) {\n    var x = xCoord / this.radius,\n        y = yCoord / this.radius,\n        fi0 = 0,\n        lambda0 = c * this.radDeg,\n        fi1 = 29.5 * this.radDeg,\n        fi2 = 45.5 * this.radDeg,\n        n = (Math.sin(fi1)+Math.sin(fi2)) / 2,\n        C = Math.cos(fi1)*Math.cos(fi1)+2*n*Math.sin(fi1),\n        ro0 = Math.sqrt(C-2*n*Math.sin(fi0))/n,\n        ro = Math.sqrt(x*x+(ro0-y)*(ro0-y)),\n        theta = Math.atan( x / (ro0 - y) );\n     return {\n      lat: (Math.asin((C - ro * ro * n * n) / (2 * n))) * this.degRad,\n      lng: (lambda0 + theta / n) * this.degRad\n    };\n  }, */\n  lcc: function lcc(lat, lng, c) {\n    var fi0 = 0,\n      lambda0 = c * this.radDeg,\n      lambda = lng * this.radDeg,\n      fi1 = 33 * this.radDeg,\n      fi2 = 45 * this.radDeg,\n      fi = lat * this.radDeg,\n      n = Math.log(Math.cos(fi1) * (1 / Math.cos(fi2))) / Math.log(Math.tan(Math.PI / 4 + fi2 / 2) * (1 / Math.tan(Math.PI / 4 + fi1 / 2))),\n      F = Math.cos(fi1) * Math.pow(Math.tan(Math.PI / 4 + fi1 / 2), n) / n,\n      ro = F * Math.pow(1 / Math.tan(Math.PI / 4 + fi / 2), n),\n      ro0 = F * Math.pow(1 / Math.tan(Math.PI / 4 + fi0 / 2), n);\n    return {\n      x: ro * Math.sin(n * (lambda - lambda0)) * this.radius,\n      y: -(ro0 - ro * Math.cos(n * (lambda - lambda0))) * this.radius\n    };\n  }\n  /* lcc_inv(xCoord, yCoord, c) {\n    var x = xCoord / this.radius,\n        y = yCoord / this.radius,\n        fi0 = 0,\n        lambda0 = c * this.radDeg,\n        fi1 = 33 * this.radDeg,\n        fi2 = 45 * this.radDeg,\n        n = Math.log( Math.cos(fi1) * (1 / Math.cos(fi2)) ) / Math.log( Math.tan( Math.PI / 4 + fi2 / 2) * (1 / Math.tan( Math.PI / 4 + fi1 / 2) ) ),\n        F = ( Math.cos(fi1) * Math.pow( Math.tan( Math.PI / 4 + fi1 / 2 ), n ) ) / n,\n        ro0 = F * Math.pow( 1 / Math.tan( Math.PI / 4 + fi0 / 2 ), n ),\n        ro = this.sgn(n) * Math.sqrt(x*x+(ro0-y)*(ro0-y)),\n        theta = Math.atan( x / (ro0 - y) );\n     return {\n      lat: (2 * Math.atan(Math.pow(F/ro, 1/n)) - Math.PI / 2) * this.degRad,\n      lng: (lambda0 + theta / n) * this.degRad\n    };\n  } */\n};\nProj.degRad = 180 / Math.PI;\nProj.radDeg = Math.PI / 180;\nProj.radius = 6381372;\n\nfunction coordsToPoint(lat, lng) {\n  var projection = Map.maps[this.params.map].projection;\n  var _Proj$projection$type = Proj[projection.type](lat, lng, projection.centralMeridian),\n    x = _Proj$projection$type.x,\n    y = _Proj$projection$type.y;\n  var inset = this.getInsetForPoint(x, y);\n  if (!inset) {\n    return false;\n  }\n  var bbox = inset.bbox;\n  x = (x - bbox[0].x) / (bbox[1].x - bbox[0].x) * inset.width * this.scale;\n  y = (y - bbox[0].y) / (bbox[1].y - bbox[0].y) * inset.height * this.scale;\n  return {\n    x: x + this.transX * this.scale + inset.left * this.scale,\n    y: y + this.transY * this.scale + inset.top * this.scale\n  };\n}\n\nfunction getInsetForPoint(x, y) {\n  var insets = Map.maps[this.params.map].insets;\n  for (var index = 0; index < insets.length; index++) {\n    var _insets$index$bbox = insets[index].bbox,\n      start = _insets$index$bbox[0],\n      end = _insets$index$bbox[1];\n    if (x > start.x && x < end.x && y > start.y && y < end.y) {\n      return insets[index];\n    }\n  }\n}\n\nfunction getMarkerPosition(_ref) {\n  var coords = _ref.coords;\n  if (Map.maps[this.params.map].projection) {\n    return this.coordsToPoint.apply(this, coords);\n  }\n  return {\n    x: coords[0] * this.scale + this.transX * this.scale,\n    y: coords[1] * this.scale + this.transY * this.scale\n  };\n}\n\nfunction repositionLines() {\n  var point1 = false,\n    point2 = false;\n  for (var index in this._lines) {\n    for (var mindex in this._markers) {\n      var marker = this._markers[mindex];\n      if (marker.config.name === this._lines[index].config.from) {\n        point1 = this.getMarkerPosition(marker.config);\n      }\n      if (marker.config.name === this._lines[index].config.to) {\n        point2 = this.getMarkerPosition(marker.config);\n      }\n    }\n    if (point1 !== false && point2 !== false) {\n      this._lines[index].setStyle({\n        x1: point1.x,\n        y1: point1.y,\n        x2: point2.x,\n        y2: point2.y\n      });\n    }\n  }\n}\n\nfunction repositionMarkers() {\n  for (var index in this._markers) {\n    var point = this.getMarkerPosition(this._markers[index].config);\n    if (point !== false) {\n      this._markers[index].element.setStyle({\n        cx: point.x,\n        cy: point.y\n      });\n    }\n  }\n}\n\nfunction repositionLabels() {\n  var labels = this.params.labels;\n  if (!labels) {\n    return;\n  }\n\n  // Regions labels\n  if (labels.regions) {\n    for (var key in this.regions) {\n      this.regions[key].element.updateLabelPosition();\n    }\n  }\n\n  // Markers labels\n  if (labels.markers) {\n    for (var _key in this._markers) {\n      this._markers[_key].element.updateLabelPosition();\n    }\n  }\n}\n\nvar core = {\n  _setupContainerEvents: setupContainerEvents,\n  _setupElementEvents: setupElementEvents,\n  _setupZoomButtons: setupZoomButtons,\n  _setupContainerTouchEvents: setupContainerTouchEvents,\n  _createRegions: createRegions,\n  _createLines: createLines,\n  _createMarkers: createMarkers,\n  _createSeries: createSeries,\n  _applyTransform: applyTransform,\n  _resize: resize,\n  _setScale: setScale,\n  setFocus: setFocus,\n  updateSize: updateSize,\n  coordsToPoint: coordsToPoint,\n  getInsetForPoint: getInsetForPoint,\n  getMarkerPosition: getMarkerPosition,\n  _repositionLines: repositionLines,\n  _repositionMarkers: repositionMarkers,\n  _repositionLabels: repositionLabels\n};\n\nvar Defaults = {\n  map: 'world',\n  backgroundColor: 'transparent',\n  draggable: true,\n  zoomButtons: true,\n  zoomOnScroll: true,\n  zoomOnScrollSpeed: 3,\n  zoomMax: 12,\n  zoomMin: 1,\n  zoomAnimate: true,\n  showTooltip: true,\n  zoomStep: 1.5,\n  bindTouchEvents: true,\n  // Line options\n  lineStyle: {\n    stroke: '#808080',\n    strokeWidth: 1,\n    strokeLinecap: 'round'\n  },\n  // Marker options\n  markersSelectable: false,\n  markersSelectableOne: false,\n  markerStyle: {\n    initial: {\n      r: 7,\n      fill: '#374151',\n      fillOpacity: 1,\n      stroke: '#FFF',\n      strokeWidth: 5,\n      strokeOpacity: .5\n    },\n    hover: {\n      fill: '#3cc0ff',\n      cursor: 'pointer'\n    },\n    selected: {\n      fill: 'blue'\n    },\n    selectedHover: {}\n  },\n  markerLabelStyle: {\n    initial: {\n      fontFamily: 'Verdana',\n      fontSize: 12,\n      fontWeight: 500,\n      cursor: 'default',\n      fill: '#374151'\n    },\n    hover: {\n      cursor: 'pointer'\n    },\n    selected: {},\n    selectedHover: {}\n  },\n  // Region options\n  regionsSelectable: false,\n  regionsSelectableOne: false,\n  regionStyle: {\n    initial: {\n      fill: '#dee2e8',\n      fillOpacity: 1,\n      stroke: 'none',\n      strokeWidth: 0\n    },\n    hover: {\n      fillOpacity: .7,\n      cursor: 'pointer'\n    },\n    selected: {\n      fill: '#9ca3af'\n    },\n    selectedHover: {}\n  },\n  regionLabelStyle: {\n    initial: {\n      fontFamily: 'Verdana',\n      fontSize: '12',\n      fontWeight: 'bold',\n      cursor: 'default',\n      fill: '#35373e'\n    },\n    hover: {\n      cursor: 'pointer'\n    }\n  }\n};\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar SVGElement = /*#__PURE__*/function () {\n  function SVGElement(name, config) {\n    this.node = this._createElement(name);\n    if (config) {\n      this.set(config);\n    }\n  }\n\n  // Create new SVG element `svg`, `g`, `path`, `line`, `circle`, `image`, etc.\n  // https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS#important_namespace_uris\n  var _proto = SVGElement.prototype;\n  _proto._createElement = function _createElement(tagName) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n  };\n  _proto.addClass = function addClass(className) {\n    this.node.setAttribute('class', className);\n  };\n  _proto.getBBox = function getBBox() {\n    return this.node.getBBox();\n  }\n\n  // Apply attributes on the current node element\n  ;\n  _proto.set = function set(property, value) {\n    if (typeof property === 'object') {\n      for (var attr in property) {\n        this.applyAttr(attr, property[attr]);\n      }\n    } else {\n      this.applyAttr(property, value);\n    }\n  };\n  _proto.get = function get(property) {\n    return this.style.initial[property];\n  };\n  _proto.applyAttr = function applyAttr(property, value) {\n    this.node.setAttribute(hyphenate(property), value);\n  };\n  _proto.remove = function remove() {\n    removeElement(this.node);\n  };\n  return SVGElement;\n}();\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar SVGShapeElement = /*#__PURE__*/function (_SVGElement) {\n  function SVGShapeElement(name, config, style) {\n    var _this;\n    if (style === void 0) {\n      style = {};\n    }\n    _this = _SVGElement.call(this, name, config) || this;\n    _this.isHovered = false;\n    _this.isSelected = false;\n    _this.style = style;\n    _this.style.current = {};\n    _this.updateStyle();\n    return _this;\n  }\n  _inheritsLoose(SVGShapeElement, _SVGElement);\n  var _proto = SVGShapeElement.prototype;\n  _proto.setStyle = function setStyle(property, value) {\n    if (typeof property === 'object') {\n      merge(this.style.current, property);\n    } else {\n      var _merge;\n      merge(this.style.current, (_merge = {}, _merge[property] = value, _merge));\n    }\n    this.updateStyle();\n  };\n  _proto.updateStyle = function updateStyle() {\n    var attrs = {};\n    merge(attrs, this.style.initial);\n    merge(attrs, this.style.current);\n    if (this.isHovered) {\n      merge(attrs, this.style.hover);\n    }\n    if (this.isSelected) {\n      merge(attrs, this.style.selected);\n      if (this.isHovered) {\n        merge(attrs, this.style.selectedHover);\n      }\n    }\n    this.set(attrs);\n  };\n  return SVGShapeElement;\n}(SVGElement);\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar SVGTextElement = /*#__PURE__*/function (_SVGShapeElement) {\n  function SVGTextElement(config, style) {\n    return _SVGShapeElement.call(this, 'text', config, style) || this;\n  }\n  _inheritsLoose(SVGTextElement, _SVGShapeElement);\n  var _proto = SVGTextElement.prototype;\n  _proto.applyAttr = function applyAttr(attr, value) {\n    attr === 'text' ? this.node.textContent = value : _SVGShapeElement.prototype.applyAttr.call(this, attr, value);\n  };\n  return SVGTextElement;\n}(SVGShapeElement);\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar SVGImageElement = /*#__PURE__*/function (_SVGShapeElement) {\n  function SVGImageElement(config, style) {\n    return _SVGShapeElement.call(this, 'image', config, style) || this;\n  }\n  _inheritsLoose(SVGImageElement, _SVGShapeElement);\n  var _proto = SVGImageElement.prototype;\n  _proto.applyAttr = function applyAttr(attr, value) {\n    var imageUrl;\n    if (attr === 'image') {\n      // This get executed when we have url in series.markers[0].scale.someScale.url\n      if (typeof value === 'object') {\n        imageUrl = value.url;\n        this.offset = value.offset || [0, 0];\n      } else {\n        imageUrl = value;\n        this.offset = [0, 0];\n      }\n      this.node.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imageUrl);\n\n      // Set width and height then call this `applyAttr` again\n      this.width = 23;\n      this.height = 23;\n      this.applyAttr('width', this.width);\n      this.applyAttr('height', this.height);\n      this.applyAttr('x', this.cx - this.width / 2 + this.offset[0]);\n      this.applyAttr('y', this.cy - this.height / 2 + this.offset[1]);\n    } else if (attr == 'cx') {\n      this.cx = value;\n      if (this.width) {\n        this.applyAttr('x', value - this.width / 2 + this.offset[0]);\n      }\n    } else if (attr == 'cy') {\n      this.cy = value;\n      if (this.height) {\n        this.applyAttr('y', value - this.height / 2 + this.offset[1]);\n      }\n    } else {\n      // This time Call SVGElement\n      _SVGShapeElement.prototype.applyAttr.apply(this, arguments);\n    }\n  };\n  return SVGImageElement;\n}(SVGShapeElement);\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar SVGCanvasElement = /*#__PURE__*/function (_SVGElement) {\n  function SVGCanvasElement(container) {\n    var _this;\n    _this = _SVGElement.call(this, 'svg') || this; // Create svg element for holding the whole map\n\n    _this._container = container;\n\n    // Create the defs element\n    _this._defsElement = new SVGElement('defs');\n\n    // Create group element which will hold the paths (regions)\n    _this._rootElement = new SVGElement('g', {\n      id: 'jvm-regions-group'\n    });\n\n    // Append the defs element to the this.node (SVG tag)\n    _this.node.appendChild(_this._defsElement.node);\n\n    // Append the group to this.node (SVG tag)\n    _this.node.appendChild(_this._rootElement.node);\n\n    // Append this.node (SVG tag) to the container\n    _this._container.appendChild(_this.node);\n    return _this;\n  }\n  _inheritsLoose(SVGCanvasElement, _SVGElement);\n  var _proto = SVGCanvasElement.prototype;\n  _proto.setSize = function setSize(width, height) {\n    this.node.setAttribute('width', width);\n    this.node.setAttribute('height', height);\n  };\n  _proto.applyTransformParams = function applyTransformParams(scale, transX, transY) {\n    this._rootElement.node.setAttribute('transform', \"scale(\" + scale + \") translate(\" + transX + \", \" + transY + \")\");\n  }\n\n  // Create `path` element\n  ;\n  _proto.createPath = function createPath(config, style) {\n    var path = new SVGShapeElement('path', config, style);\n    path.node.setAttribute('fill-rule', 'evenodd');\n    return this._add(path);\n  }\n\n  // Create `circle` element\n  ;\n  _proto.createCircle = function createCircle(config, style, group) {\n    var circle = new SVGShapeElement('circle', config, style);\n    return this._add(circle, group);\n  }\n\n  // Create `line` element\n  ;\n  _proto.createLine = function createLine(config, style, group) {\n    var line = new SVGShapeElement('line', config, style);\n    return this._add(line, group);\n  }\n\n  // Create `text` element\n  ;\n  _proto.createText = function createText(config, style, group) {\n    var text = new SVGTextElement(config, style);\n    return this._add(text, group);\n  }\n\n  // Create `image` element\n  ;\n  _proto.createImage = function createImage(config, style, group) {\n    var image = new SVGImageElement(config, style);\n    return this._add(image, group);\n  }\n\n  // Create `g` element\n  ;\n  _proto.createGroup = function createGroup(id) {\n    var group = new SVGElement('g');\n    this.node.appendChild(group.node);\n    if (id) {\n      group.node.id = id;\n    }\n    group.canvas = this;\n    return group;\n  }\n\n  // Add some element to a spcific group or the root element if the group isn't given\n  ;\n  _proto._add = function _add(element, group) {\n    group = group || this._rootElement;\n    group.node.appendChild(element.node);\n    return element;\n  };\n  return SVGCanvasElement;\n}(SVGElement);\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar Tooltip = /*#__PURE__*/function (_BaseComponent) {\n  function Tooltip(map) {\n    var _this;\n    _this = _BaseComponent.call(this) || this;\n    var tooltip = createElement('div', 'jvm-tooltip');\n    _this._map = map;\n    _this._tooltip = document.body.appendChild(tooltip);\n    _this._bindEventListeners();\n    return _this || _assertThisInitialized(_this);\n  }\n  _inheritsLoose(Tooltip, _BaseComponent);\n  var _proto = Tooltip.prototype;\n  _proto._bindEventListeners = function _bindEventListeners() {\n    var _this2 = this;\n    EventHandler.on(this._map.container, 'mousemove', function (event) {\n      if (!_this2._tooltip.classList.contains('active')) {\n        return;\n      }\n      var container = findElement(_this2._map.container, '#jvm-regions-group').getBoundingClientRect();\n      var space = 5; // Space between the cursor and tooltip element\n\n      // Tooltip\n      var _this2$_tooltip$getBo = _this2._tooltip.getBoundingClientRect(),\n        height = _this2$_tooltip$getBo.height,\n        width = _this2$_tooltip$getBo.width;\n      var topIsPassed = event.clientY <= container.top + height + space;\n      var top = event.pageY - height - space;\n      var left = event.pageX - width - space;\n\n      // Ensure the tooltip will never cross outside the canvas area(map)\n      if (topIsPassed) {\n        // Top:\n        top += height + space;\n\n        // The cursor is a bit larger from left side\n        left -= space * 2;\n      }\n      if (event.clientX < container.left + width + space) {\n        // Left:\n        left = event.pageX + space + 2;\n        if (topIsPassed) {\n          left += space * 2;\n        }\n      }\n      _this2.css({\n        top: top + \"px\",\n        left: left + \"px\"\n      });\n    });\n  };\n  _proto.getElement = function getElement() {\n    return this._tooltip;\n  };\n  _proto.show = function show() {\n    this._tooltip.classList.add('active');\n  };\n  _proto.hide = function hide() {\n    this._tooltip.classList.remove('active');\n  };\n  _proto.text = function text(string, html) {\n    if (html === void 0) {\n      html = false;\n    }\n    var property = html ? 'innerHTML' : 'textContent';\n    if (!string) {\n      return this._tooltip[property];\n    }\n    this._tooltip[property] = string;\n  };\n  _proto.css = function css(_css) {\n    for (var style in _css) {\n      this._tooltip.style[style] = _css[style];\n    }\n    return this;\n  };\n  return Tooltip;\n}(BaseComponent);\n\nvar DataVisualization = /*#__PURE__*/function () {\n  function DataVisualization(_ref, map) {\n    var scale = _ref.scale,\n      values = _ref.values;\n    this._scale = scale;\n    this._values = values;\n    this._fromColor = this.hexToRgb(scale[0]);\n    this._toColor = this.hexToRgb(scale[1]);\n    this._map = map;\n    this.setMinMaxValues(values);\n    this.visualize();\n  }\n  var _proto = DataVisualization.prototype;\n  _proto.setMinMaxValues = function setMinMaxValues(values) {\n    this.min = Number.MAX_VALUE;\n    this.max = 0;\n    for (var value in values) {\n      value = parseFloat(values[value]);\n      if (value > this.max) {\n        this.max = value;\n      }\n      if (value < this.min) {\n        this.min = value;\n      }\n    }\n  };\n  _proto.visualize = function visualize() {\n    var attrs = {},\n      value;\n    for (var regionCode in this._values) {\n      value = parseFloat(this._values[regionCode]);\n      if (!isNaN(value)) {\n        attrs[regionCode] = this.getValue(value);\n      }\n    }\n    this.setAttributes(attrs);\n  };\n  _proto.setAttributes = function setAttributes(attrs) {\n    for (var code in attrs) {\n      if (this._map.regions[code]) {\n        this._map.regions[code].element.setStyle('fill', attrs[code]);\n      }\n    }\n  };\n  _proto.getValue = function getValue(value) {\n    if (this.min === this.max) {\n      return \"#\" + this._toColor.join('');\n    }\n    var hex,\n      color = '#';\n    for (var i = 0; i < 3; i++) {\n      hex = Math.round(this._fromColor[i] + (this._toColor[i] - this._fromColor[i]) * ((value - this.min) / (this.max - this.min))).toString(16);\n      color += (hex.length === 1 ? '0' : '') + hex;\n    }\n    return color;\n  };\n  _proto.hexToRgb = function hexToRgb(h) {\n    var r = 0,\n      g = 0,\n      b = 0;\n    if (h.length == 4) {\n      r = '0x' + h[1] + h[1];\n      g = '0x' + h[2] + h[2];\n      b = '0x' + h[3] + h[3];\n    } else if (h.length == 7) {\n      r = '0x' + h[1] + h[2];\n      g = '0x' + h[3] + h[4];\n      b = '0x' + h[5] + h[6];\n    }\n    return [parseInt(r), parseInt(g), parseInt(b)];\n  };\n  return DataVisualization;\n}();\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar Map = /*#__PURE__*/function () {\n  function Map(options) {\n    var _this = this;\n    if (options === void 0) {\n      options = {};\n    }\n    // Merge the given options with the default options\n    this.params = merge(Map.defaults, options, true);\n\n    // Throw an error if the given map name doesn't match\n    // the map that was set in map file\n    if (!Map.maps[this.params.map]) {\n      throw new Error(\"Attempt to use map which was not loaded: \" + options.map);\n    }\n    this.regions = {};\n    this.scale = 1;\n    this.transX = 0;\n    this.transY = 0;\n    this._mapData = Map.maps[this.params.map];\n    this._markers = {};\n    this._lines = {};\n    this._defaultWidth = this._mapData.width;\n    this._defaultHeight = this._mapData.height;\n    this._height = 0;\n    this._width = 0;\n    this._baseScale = 1;\n    this._baseTransX = 0;\n    this._baseTransY = 0;\n\n    // `document` is already ready, just initialise now\n    if (document.readyState !== 'loading') {\n      this._init();\n    } else {\n      // Wait until `document` is ready\n      window.addEventListener('DOMContentLoaded', function () {\n        return _this._init();\n      });\n    }\n  }\n  var _proto = Map.prototype;\n  _proto._init = function _init() {\n    var options = this.params;\n    this.container = getElement(options.selector);\n    this.container.classList.add('jvm-container');\n\n    // The map canvas element\n    this.canvas = new SVGCanvasElement(this.container);\n\n    // Set the map's background color\n    this.setBackgroundColor(options.backgroundColor);\n\n    // Create regions\n    this._createRegions();\n\n    // Update size\n    this.updateSize();\n\n    // Create lines\n    this._createLines(options.lines || {}, options.markers || {});\n\n    // Create markers\n    this._createMarkers(options.markers);\n\n    // Position labels\n    this._repositionLabels();\n\n    // Setup the container events\n    this._setupContainerEvents();\n\n    // Setup regions/markers events\n    this._setupElementEvents();\n\n    // Create zoom buttons if `zoomButtons` is presented\n    if (options.zoomButtons) {\n      this._setupZoomButtons();\n    }\n\n    // Create toolip\n    if (options.showTooltip) {\n      this._tooltip = new Tooltip(this);\n    }\n\n    // Set selected regions if any\n    if (options.selectedRegions) {\n      this._setSelected('regions', options.selectedRegions);\n    }\n\n    // Set selected regions if any\n    if (options.selectedMarkers) {\n      this._setSelected('_markers', options.selectedMarkers);\n    }\n\n    // Set focus on a spcific region\n    if (options.focusOn) {\n      this.setFocus(options.focusOn);\n    }\n\n    // Data visualization\n    if (options.visualizeData) {\n      this.dataVisualization = new DataVisualization(options.visualizeData, this);\n    }\n\n    // Bind touch events if true\n    if (options.bindTouchEvents) {\n      if ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch) {\n        this._setupContainerTouchEvents();\n      }\n    }\n\n    // Create series if any\n    if (options.series) {\n      this.container.appendChild(this.legendHorizontal = createElement('div', 'jvm-series-container jvm-series-h'));\n      this.container.appendChild(this.legendVertical = createElement('div', 'jvm-series-container jvm-series-v'));\n      this._createSeries();\n    }\n\n    // Fire loaded event\n    this._emit(Events.onLoaded, [this]);\n  }\n\n  // Public\n  ;\n  _proto.setBackgroundColor = function setBackgroundColor(color) {\n    this.container.style.backgroundColor = color;\n  }\n\n  // Region methods\n  ;\n  _proto.getSelectedRegions = function getSelectedRegions() {\n    return this._getSelected('regions');\n  };\n  _proto.clearSelectedRegions = function clearSelectedRegions(regions) {\n    var _this2 = this;\n    if (regions === void 0) {\n      regions = undefined;\n    }\n    regions = this._normalizeRegions(regions) || this._getSelected('regions');\n    regions.forEach(function (key) {\n      _this2.regions[key].element.select(false);\n    });\n  };\n  _proto.setSelectedRegions = function setSelectedRegions(regions) {\n    this.clearSelectedRegions();\n    this._setSelected('regions', this._normalizeRegions(regions));\n  }\n\n  // Markers methods\n  ;\n  _proto.getSelectedMarkers = function getSelectedMarkers() {\n    return this._getSelected('_markers');\n  };\n  _proto.clearSelectedMarkers = function clearSelectedMarkers() {\n    this._clearSelected('_markers');\n  };\n  _proto.addMarkers = function addMarkers(config) {\n    config = Array.isArray(config) ? config : [config];\n    this._createMarkers(config, true);\n  };\n  _proto.removeMarkers = function removeMarkers(markers) {\n    var _this3 = this;\n    if (!markers) {\n      markers = Object.keys(this._markers);\n    }\n    markers.forEach(function (index) {\n      // Remove the element from the DOM\n      _this3._markers[index].element.remove();\n      // Remove the element from markers object\n      delete _this3._markers[index];\n    });\n  };\n  _proto.addLine = function addLine(from, to, style) {\n    if (style === void 0) {\n      style = {};\n    }\n    console.warn('`addLine` method is deprecated, please use `addLines` instead.');\n    this._createLines([{\n      from: from,\n      to: to,\n      style: style\n    }], this._markers, true);\n  };\n  _proto.addLines = function addLines(config) {\n    var uids = this._getLinesAsUids();\n    if (!Array.isArray(config)) {\n      config = [config];\n    }\n    this._createLines(config.filter(function (line) {\n      return !(uids.indexOf(getLineUid(line.from, line.to)) > -1);\n    }), this._markers, true);\n  };\n  _proto.removeLines = function removeLines(lines) {\n    var _this4 = this;\n    if (Array.isArray(lines)) {\n      lines = lines.map(function (line) {\n        return getLineUid(line.from, line.to);\n      });\n    } else {\n      lines = this._getLinesAsUids();\n    }\n    lines.forEach(function (uid) {\n      _this4._lines[uid].dispose();\n      delete _this4._lines[uid];\n    });\n  };\n  _proto.removeLine = function removeLine(from, to) {\n    console.warn('`removeLine` method is deprecated, please use `removeLines` instead.');\n    var uid = getLineUid(from, to);\n    if (this._lines.hasOwnProperty(uid)) {\n      this._lines[uid].element.remove();\n      delete this._lines[uid];\n    }\n  }\n\n  // Reset map\n  ;\n  _proto.reset = function reset() {\n    for (var key in this.series) {\n      for (var i = 0; i < this.series[key].length; i++) {\n        this.series[key][i].clear();\n      }\n    }\n    if (this.legendHorizontal) {\n      removeElement(this.legendHorizontal);\n      this.legendHorizontal = null;\n    }\n    if (this.legendVertical) {\n      removeElement(this.legendVertical);\n      this.legendVertical = null;\n    }\n    this.scale = this._baseScale;\n    this.transX = this._baseTransX;\n    this.transY = this._baseTransY;\n    this._applyTransform();\n    this.clearSelectedMarkers();\n    this.clearSelectedRegions();\n    this.removeMarkers();\n  }\n\n  // Destroy the map\n  ;\n  _proto.destroy = function destroy(destroyInstance) {\n    var _this5 = this;\n    if (destroyInstance === void 0) {\n      destroyInstance = true;\n    }\n    // Remove event registry\n    EventHandler.flush();\n\n    // Remove tooltip from DOM and memory\n    this._tooltip.dispose();\n\n    // Fire destroyed event\n    this._emit(Events.onDestroyed);\n\n    // Remove references\n    if (destroyInstance) {\n      Object.keys(this).forEach(function (key) {\n        try {\n          delete _this5[key];\n        } catch (e) {}\n      });\n    }\n  };\n  _proto.extend = function extend(name, callback) {\n    if (typeof this[name] === 'function') {\n      throw new Error(\"The method [\" + name + \"] does already exist, please use another name.\");\n    }\n    Map.prototype[name] = callback;\n  }\n\n  // Private\n  ;\n  _proto._emit = function _emit(eventName, args) {\n    for (var event in Events) {\n      if (Events[event] === eventName && typeof this.params[event] === 'function') {\n        this.params[event].apply(this, args);\n      }\n    }\n  }\n\n  // Get selected markers/regions\n  ;\n  _proto._getSelected = function _getSelected(type) {\n    var selected = [];\n    for (var key in this[type]) {\n      if (this[type][key].element.isSelected) {\n        selected.push(key);\n      }\n    }\n    return selected;\n  };\n  _proto._setSelected = function _setSelected(type, keys) {\n    var _this6 = this;\n    keys.forEach(function (key) {\n      if (_this6[type][key]) {\n        _this6[type][key].element.select(true);\n      }\n    });\n  };\n  _proto._clearSelected = function _clearSelected(type) {\n    var _this7 = this;\n    this._getSelected(type).forEach(function (key) {\n      _this7[type][key].element.select(false);\n    });\n  };\n  _proto._getLinesAsUids = function _getLinesAsUids() {\n    return Object.keys(this._lines);\n  };\n  _proto._normalizeRegions = function _normalizeRegions(regions) {\n    return typeof regions === 'string' ? [regions] : regions;\n  };\n  return Map;\n}();\nMap.maps = {};\nMap.defaults = Defaults;\nObject.assign(Map.prototype, core);\n\n/**\n * jsVectorMap\n * Copyrights (c) Mustafa Omar https://github.com/themustafaomar\n * Released under the MIT License.\n */\n\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\nvar jsVectorMap = /*#__PURE__*/function () {\n  function jsVectorMap(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!options.selector) {\n      throw new Error('Selector is not given.');\n    }\n    return new Map(options);\n  }\n\n  // Public\n  jsVectorMap.addMap = function addMap(name, map) {\n    Map.maps[name] = map;\n  };\n  return jsVectorMap;\n}();\nvar index = window.jsVectorMap = jsVectorMap;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN2ZWN0b3JtYXAvZGlzdC9qc3ZlY3Rvcm1hcC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsNEJBQTRCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG9CQUFvQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLHVCQUF1Qjs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUU0QiIsInNvdXJjZXMiOlsiRDpcXFdvcmtwbGFjZVxcZGFzaEJvYXJkRVJQXFxkYXNoQm9hcmRFUlBcXG5vZGVfbW9kdWxlc1xcanN2ZWN0b3JtYXBcXGRpc3RcXGpzdmVjdG9ybWFwLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWhTaHJpa2UvZGVlcG1lcmdlXG4gKi9cblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkgJiYgIWlzU3BlY2lhbCh2YWx1ZSk7XG59O1xuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcbiAgdmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJyB8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nIHx8IGlzTm9kZSh2YWx1ZSkgfHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpO1xufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZTtcbn1cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fTtcbn1cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSA/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG4gICAgcmV0dXJuIGRlZXBtZXJnZTtcbiAgfVxuICB2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG4gIHJldHVybiB0eXBlb2YgY3VzdG9tTWVyZ2UgPT09ICdmdW5jdGlvbicgPyBjdXN0b21NZXJnZSA6IGRlZXBtZXJnZTtcbn1cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgcmV0dXJuIHRhcmdldC5wcm9wZXJ0eUlzRW51bWVyYWJsZShzeW1ib2wpO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gZ2V0S2V5cyh0YXJnZXQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0eUlzT25PYmplY3Qob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB0cnkge1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Q7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gUHJvdGVjdHMgZnJvbSBwcm90b3R5cGUgcG9pc29uaW5nIGFuZCB1bmV4cGVjdGVkIG1lcmdpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbmZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgLy8gUHJvcGVydGllcyBhcmUgc2FmZSB0byBtZXJnZSBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgeWV0LFxuICAmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuICAmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpOyAvLyBhbmQgYWxzbyB1bnNhZmUgaWYgdGhleSdyZSBub25lbnVtZXJhYmxlLlxufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGRlc3RpbmF0aW9uID0ge307XG4gIGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcbiAgICBnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAocHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZVtrZXldLCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGVzdGluYXRpb247XG59XG52YXIgZGVlcG1lcmdlID0gZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG4gIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuICAvLyBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCBpcyBhZGRlZCB0byBgb3B0aW9uc2Agc28gdGhhdCBjdXN0b20gYXJyYXlNZXJnZSgpXG4gIC8vIGltcGxlbWVudGF0aW9ucyBjYW4gdXNlIGl0LiBUaGUgY2FsbGVyIG1heSBub3QgcmVwbGFjZSBpdC5cbiAgb3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuICB2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcbiAgdmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG4gIHZhciBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcbiAgaWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG4gICAgcmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuICAgIHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFB1YmxpYyBVdGlsIEFwaVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xudmFyIGdldEVsZW1lbnQgPSBmdW5jdGlvbiBnZXRFbGVtZW50KHNlbGVjdG9yKSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZWxlY3Rvci5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZWN0b3I7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNsYXNzZXMsIGNvbnRlbnQsIGh0bWwpIHtcbiAgaWYgKGh0bWwgPT09IHZvaWQgMCkge1xuICAgIGh0bWwgPSBmYWxzZTtcbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICBpZiAoY29udGVudCkge1xuICAgIGVsWyFodG1sID8gJ3RleHRDb250ZW50JyA6ICdpbm5lckhUTUwnXSA9IGNvbnRlbnQ7XG4gIH1cbiAgaWYgKGNsYXNzZXMpIHtcbiAgICBlbC5jbGFzc05hbWUgPSBjbGFzc2VzO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG52YXIgZmluZEVsZW1lbnQgPSBmdW5jdGlvbiBmaW5kRWxlbWVudChwYXJlbnRFbGVtZW50LCBzZWxlY3Rvcikge1xuICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKHBhcmVudEVsZW1lbnQsIHNlbGVjdG9yKTtcbn07XG52YXIgcmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQodGFyZ2V0KSB7XG4gIHRhcmdldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhcmdldCk7XG59O1xudmFyIGlzSW1hZ2VVcmwgPSBmdW5jdGlvbiBpc0ltYWdlVXJsKHVybCkge1xuICByZXR1cm4gL1xcLihqcGd8Z2lmfHBuZykkLy50ZXN0KHVybCk7XG59O1xudmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFx3XShbQS1aXSkvZywgZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gbVswXSArIFwiLVwiICsgbVsxXTtcbiAgfSkudG9Mb3dlckNhc2UoKTtcbn07XG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgZGVlcCkge1xuICBpZiAoZGVlcCA9PT0gdm9pZCAwKSB7XG4gICAgZGVlcCA9IGZhbHNlO1xuICB9XG4gIGlmIChkZWVwKSB7XG4gICAgcmV0dXJuIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpO1xufTtcbnZhciBnZXRMaW5lVWlkID0gZnVuY3Rpb24gZ2V0TGluZVVpZChmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS50b0xvd2VyQ2FzZSgpICsgXCI6dG86XCIgKyB0by50b0xvd2VyQ2FzZSgpO1xufTtcbnZhciBpbmhlcml0ID0gZnVuY3Rpb24gaW5oZXJpdCh0YXJnZXQsIHNvdXJjZSkge1xuICBPYmplY3QuYXNzaWduKHRhcmdldC5wcm90b3R5cGUsIHNvdXJjZSk7XG59O1xuXG52YXIgZXZlbnRSZWdpc3RyeSA9IHt9O1xudmFyIGV2ZW50VWlkID0gMTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEV2ZW50IEhhbmRsZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG52YXIgRXZlbnRIYW5kbGVyID0ge1xuICBvbjogZnVuY3Rpb24gb24oZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHZhciB1aWQgPSBcImp2bTpcIiArIGV2ZW50ICsgXCI6OlwiICsgZXZlbnRVaWQrKztcbiAgICBldmVudFJlZ2lzdHJ5W3VpZF0gPSB7XG4gICAgICBzZWxlY3RvcjogZWxlbWVudCxcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICB9O1xuICAgIGhhbmRsZXIuX3VpZCA9IHVpZDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICB9LFxuICBkZWxlZ2F0ZTogZnVuY3Rpb24gZGVsZWdhdGUoZWxlbWVudCwgZXZlbnQsIHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgZXZlbnQgPSBldmVudC5zcGxpdCgnICcpO1xuICAgIGV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRhcmdldCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBvZmY6IGZ1bmN0aW9uIG9mZihlbGVtZW50LCBldmVudCwgaGFuZGxlcikge1xuICAgIHZhciBldmVudFR5cGUgPSBldmVudC5zcGxpdCgnOicpWzFdO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIpO1xuICAgIGRlbGV0ZSBldmVudFJlZ2lzdHJ5W2hhbmRsZXIuX3VpZF07XG4gIH0sXG4gIGZsdXNoOiBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBPYmplY3Qua2V5cyhldmVudFJlZ2lzdHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9mZihldmVudFJlZ2lzdHJ5W2V2ZW50XS5zZWxlY3RvciwgZXZlbnQsIGV2ZW50UmVnaXN0cnlbZXZlbnRdLmhhbmRsZXIpO1xuICAgIH0pO1xuICB9LFxuICBnZXRFdmVudFJlZ2lzdHJ5OiBmdW5jdGlvbiBnZXRFdmVudFJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiBldmVudFJlZ2lzdHJ5O1xuICB9XG59O1xuXG5mdW5jdGlvbiBzZXR1cENvbnRhaW5lckV2ZW50cygpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIG1hcCA9IHRoaXM7XG4gIHZhciBtb3VzZURvd24gPSBmYWxzZTtcbiAgdmFyIG9sZFBhZ2VYO1xuICB2YXIgb2xkUGFnZVk7XG4gIGlmICh0aGlzLnBhcmFtcy5kcmFnZ2FibGUpIHtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5jb250YWluZXIsICdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFtb3VzZURvd24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbWFwLnRyYW5zWCAtPSAob2xkUGFnZVggLSBlLnBhZ2VYKSAvIG1hcC5zY2FsZTtcbiAgICAgIG1hcC50cmFuc1kgLT0gKG9sZFBhZ2VZIC0gZS5wYWdlWSkgLyBtYXAuc2NhbGU7XG4gICAgICBtYXAuX2FwcGx5VHJhbnNmb3JtKCk7XG4gICAgICBvbGRQYWdlWCA9IGUucGFnZVg7XG4gICAgICBvbGRQYWdlWSA9IGUucGFnZVk7XG4gICAgfSk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICBvbGRQYWdlWCA9IGUucGFnZVg7XG4gICAgICBvbGRQYWdlWSA9IGUucGFnZVk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LmJvZHksICdtb3VzZXVwJywgZnVuY3Rpb24gKCkge1xuICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHRoaXMucGFyYW1zLnpvb21PblNjcm9sbCkge1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLmNvbnRhaW5lciwgJ3doZWVsJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgZGVsdGFZID0gKChldmVudC5kZWx0YVkgfHwgLWV2ZW50LndoZWVsRGVsdGEgfHwgZXZlbnQuZGV0YWlsKSA+PiAxMCB8fCAxKSAqIDc1O1xuICAgICAgdmFyIHJlY3QgPSBfdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgb2Zmc2V0WCA9IGV2ZW50LnBhZ2VYIC0gcmVjdC5sZWZ0IC0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgdmFyIG9mZnNldFkgPSBldmVudC5wYWdlWSAtIHJlY3QudG9wIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgdmFyIHpvb21TdGVwID0gTWF0aC5wb3coMSArIG1hcC5wYXJhbXMuem9vbU9uU2Nyb2xsU3BlZWQgLyAxMDAwLCAtMS41ICogZGVsdGFZKTtcbiAgICAgIGlmIChtYXAudG9vbHRpcCkge1xuICAgICAgICBtYXAuX3Rvb2x0aXAuaGlkZSgpO1xuICAgICAgfVxuICAgICAgbWFwLl9zZXRTY2FsZShtYXAuc2NhbGUgKiB6b29tU3RlcCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBFdmVudHMgPSB7XG4gIG9uTG9hZGVkOiAnbWFwOmxvYWRlZCcsXG4gIG9uVmlld3BvcnRDaGFuZ2U6ICd2aWV3cG9ydDpjaGFuZ2VkJyxcbiAgb25SZWdpb25DbGljazogJ3JlZ2lvbjpjbGlja2VkJyxcbiAgb25NYXJrZXJDbGljazogJ21hcmtlcjpjbGlja2VkJyxcbiAgb25SZWdpb25TZWxlY3RlZDogJ3JlZ2lvbjpzZWxlY3RlZCcsXG4gIG9uTWFya2VyU2VsZWN0ZWQ6ICdtYXJrZXI6c2VsZWN0ZWQnLFxuICBvblJlZ2lvblRvb2x0aXBTaG93OiAncmVnaW9uLnRvb2x0aXA6c2hvdycsXG4gIG9uTWFya2VyVG9vbHRpcFNob3c6ICdtYXJrZXIudG9vbHRpcDpzaG93JyxcbiAgb25EZXN0cm95ZWQ6ICdtYXA6ZGVzdHJveWVkJ1xufTtcblxudmFyIHBhcnNlRXZlbnQgPSBmdW5jdGlvbiBwYXJzZUV2ZW50KG1hcCwgc2VsZWN0b3IsIGlzVG9vbHRpcCkge1xuICB2YXIgZWxlbWVudCA9IGdldEVsZW1lbnQoc2VsZWN0b3IpO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLmluZGV4T2YoJ2p2bS1yZWdpb24nKSA9PT0gLTEgPyAnbWFya2VyJyA6ICdyZWdpb24nO1xuICB2YXIgaXNSZWdpb24gPSB0eXBlID09PSAncmVnaW9uJztcbiAgdmFyIGNvZGUgPSBpc1JlZ2lvbiA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvZGUnKSA6IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4Jyk7XG4gIHZhciBldmVudCA9IGlzUmVnaW9uID8gRXZlbnRzLm9uUmVnaW9uU2VsZWN0ZWQgOiBFdmVudHMub25NYXJrZXJTZWxlY3RlZDtcblxuICAvLyBJbml0IHRvb2x0aXAgZXZlbnRcbiAgaWYgKGlzVG9vbHRpcCkge1xuICAgIGV2ZW50ID0gaXNSZWdpb24gPyBFdmVudHMub25SZWdpb25Ub29sdGlwU2hvdyA6IEV2ZW50cy5vbk1hcmtlclRvb2x0aXBTaG93O1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBjb2RlOiBjb2RlLFxuICAgIGV2ZW50OiBldmVudCxcbiAgICBlbGVtZW50OiBpc1JlZ2lvbiA/IG1hcC5yZWdpb25zW2NvZGVdLmVsZW1lbnQgOiBtYXAuX21hcmtlcnNbY29kZV0uZWxlbWVudCxcbiAgICB0b29sdGlwVGV4dDogaXNSZWdpb24gPyBtYXAuX21hcERhdGEucGF0aHNbY29kZV0ubmFtZSB8fCAnJyA6IG1hcC5fbWFya2Vyc1tjb2RlXS5jb25maWcubmFtZSB8fCAnJ1xuICB9O1xufTtcbmZ1bmN0aW9uIHNldHVwRWxlbWVudEV2ZW50cygpIHtcbiAgdmFyIG1hcCA9IHRoaXM7XG4gIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgdmFyIHBhZ2VYLCBwYWdlWSwgbW91c2VNb3ZlZDtcbiAgRXZlbnRIYW5kbGVyLm9uKGNvbnRhaW5lciwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChNYXRoLmFicyhwYWdlWCAtIGV2ZW50LnBhZ2VYKSArIE1hdGguYWJzKHBhZ2VZIC0gZXZlbnQucGFnZVkpID4gMikge1xuICAgICAgbW91c2VNb3ZlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBXaGVuIHRoZSBtb3VzZSBpcyBwcmVzc2VkXG4gIEV2ZW50SGFuZGxlci5kZWxlZ2F0ZShjb250YWluZXIsICdtb3VzZWRvd24nLCAnLmp2bS1lbGVtZW50JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcGFnZVggPSBldmVudC5wYWdlWDtcbiAgICBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuICAgIG1vdXNlTW92ZWQgPSBmYWxzZTtcbiAgfSk7XG5cbiAgLy8gV2hlbiB0aGUgbW91c2UgaXMgb3ZlciB0aGUgcmVnaW9uL21hcmtlciB8IFdoZW4gdGhlIG1vdXNlIGlzIG91dCB0aGUgcmVnaW9uL21hcmtlclxuICBFdmVudEhhbmRsZXIuZGVsZWdhdGUoY29udGFpbmVyLCAnbW91c2VvdmVyIG1vdXNlb3V0JywgJy5qdm0tZWxlbWVudCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkYXRhID0gcGFyc2VFdmVudChtYXAsIHRoaXMsIHRydWUpO1xuICAgIHZhciBzaG93VG9vbHRpcCA9IG1hcC5wYXJhbXMuc2hvd1Rvb2x0aXA7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZW92ZXInKSB7XG4gICAgICBkYXRhLmVsZW1lbnQuaG92ZXIodHJ1ZSk7XG4gICAgICBpZiAoc2hvd1Rvb2x0aXApIHtcbiAgICAgICAgbWFwLl90b29sdGlwLnRleHQoZGF0YS50b29sdGlwVGV4dCk7XG4gICAgICAgIG1hcC5fdG9vbHRpcC5zaG93KCk7XG4gICAgICAgIG1hcC5fZW1pdChkYXRhLmV2ZW50LCBbZXZlbnQsIG1hcC5fdG9vbHRpcCwgZGF0YS5jb2RlXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuZWxlbWVudC5ob3ZlcihmYWxzZSk7XG4gICAgICBpZiAoc2hvd1Rvb2x0aXApIHtcbiAgICAgICAgbWFwLl90b29sdGlwLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIFdoZW4gdGhlIGNsaWNrIGlzIHJlbGVhc2VkXG4gIEV2ZW50SGFuZGxlci5kZWxlZ2F0ZShjb250YWluZXIsICdtb3VzZXVwJywgJy5qdm0tZWxlbWVudCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkYXRhID0gcGFyc2VFdmVudChtYXAsIHRoaXMpO1xuICAgIGlmIChtb3VzZU1vdmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLnR5cGUgPT09ICdyZWdpb24nICYmIG1hcC5wYXJhbXMucmVnaW9uc1NlbGVjdGFibGUgfHwgZGF0YS50eXBlID09PSAnbWFya2VyJyAmJiBtYXAucGFyYW1zLm1hcmtlcnNTZWxlY3RhYmxlKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGRhdGEuZWxlbWVudDtcblxuICAgICAgLy8gV2UncmUgY2hlY2tpbmcgaWYgcmVnaW9ucy9tYXJrZXJzfFNlbGVjdGFibGVPbmUgb3B0aW9uIGlzIHByZXNlbnRlZFxuICAgICAgaWYgKG1hcC5wYXJhbXNbZGF0YS50eXBlICsgXCJzU2VsZWN0YWJsZU9uZVwiXSkge1xuICAgICAgICBtYXAuX2NsZWFyU2VsZWN0ZWQoZGF0YS50eXBlICsgXCJzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuZWxlbWVudC5pc1NlbGVjdGVkKSB7XG4gICAgICAgIGVsZW1lbnQuc2VsZWN0KGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2VsZWN0KHRydWUpO1xuICAgICAgfVxuICAgICAgbWFwLl9lbWl0KGRhdGEuZXZlbnQsIFtkYXRhLmNvZGUsIGVsZW1lbnQuaXNTZWxlY3RlZCwgbWFwLl9nZXRTZWxlY3RlZChkYXRhLnR5cGUgKyBcInNcIildKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFdoZW4gcmVnaW9uL21hcmtlciBpcyBjbGlja2VkXG4gIEV2ZW50SGFuZGxlci5kZWxlZ2F0ZShjb250YWluZXIsICdjbGljaycsICcuanZtLWVsZW1lbnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX3BhcnNlRXZlbnQgPSBwYXJzZUV2ZW50KG1hcCwgdGhpcyksXG4gICAgICB0eXBlID0gX3BhcnNlRXZlbnQudHlwZSxcbiAgICAgIGNvZGUgPSBfcGFyc2VFdmVudC5jb2RlO1xuICAgIG1hcC5fZW1pdCh0eXBlID09PSAncmVnaW9uJyA/IEV2ZW50cy5vblJlZ2lvbkNsaWNrIDogRXZlbnRzLm9uTWFya2VyQ2xpY2ssIFtldmVudCwgY29kZV0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0dXBab29tQnV0dG9ucygpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIHpvb21pbiA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsICdqdm0tem9vbS1idG4ganZtLXpvb21pbicsICcmIzQzOycsIHRydWUpO1xuICB2YXIgem9vbW91dCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsICdqdm0tem9vbS1idG4ganZtLXpvb21vdXQnLCAnJiN4MjIxMicsIHRydWUpO1xuICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh6b29taW4pO1xuICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh6b29tb3V0KTtcbiAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKHpvb21pbikge1xuICAgIGlmICh6b29taW4gPT09IHZvaWQgMCkge1xuICAgICAgem9vbWluID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fc2V0U2NhbGUoem9vbWluID8gX3RoaXMuc2NhbGUgKiBfdGhpcy5wYXJhbXMuem9vbVN0ZXAgOiBfdGhpcy5zY2FsZSAvIF90aGlzLnBhcmFtcy56b29tU3RlcCwgX3RoaXMuX3dpZHRoIC8gMiwgX3RoaXMuX2hlaWdodCAvIDIsIGZhbHNlLCBfdGhpcy5wYXJhbXMuem9vbUFuaW1hdGUpO1xuICAgIH07XG4gIH07XG4gIEV2ZW50SGFuZGxlci5vbih6b29taW4sICdjbGljaycsIGhhbmRsZXIoKSk7XG4gIEV2ZW50SGFuZGxlci5vbih6b29tb3V0LCAnY2xpY2snLCBoYW5kbGVyKGZhbHNlKSk7XG59XG5cbmZ1bmN0aW9uIHNldHVwQ29udGFpbmVyVG91Y2hFdmVudHMoKSB7XG4gIHZhciBtYXAgPSB0aGlzLFxuICAgIHRvdWNoU3RhcnRTY2FsZSxcbiAgICB0b3VjaFN0YXJ0RGlzdGFuY2UsXG4gICAgdG91Y2hYLFxuICAgIHRvdWNoWSxcbiAgICBjZW50ZXJUb3VjaFgsXG4gICAgY2VudGVyVG91Y2hZLFxuICAgIGxhc3RUb3VjaGVzTGVuZ3RoO1xuICB2YXIgaGFuZGxlVG91Y2hFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZVRvdWNoRXZlbnQoZSkge1xuICAgIHZhciB0b3VjaGVzID0gZS50b3VjaGVzO1xuICAgIHZhciBvZmZzZXQsIHNjYWxlLCB0cmFuc1hPbGQsIHRyYW5zWU9sZDtcbiAgICBpZiAoZS50eXBlID09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgbGFzdFRvdWNoZXNMZW5ndGggPSAwO1xuICAgIH1cbiAgICBpZiAodG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKGxhc3RUb3VjaGVzTGVuZ3RoID09IDEpIHtcbiAgICAgICAgdHJhbnNYT2xkID0gbWFwLnRyYW5zWDtcbiAgICAgICAgdHJhbnNZT2xkID0gbWFwLnRyYW5zWTtcbiAgICAgICAgbWFwLnRyYW5zWCAtPSAodG91Y2hYIC0gdG91Y2hlc1swXS5wYWdlWCkgLyBtYXAuc2NhbGU7XG4gICAgICAgIG1hcC50cmFuc1kgLT0gKHRvdWNoWSAtIHRvdWNoZXNbMF0ucGFnZVkpIC8gbWFwLnNjYWxlO1xuICAgICAgICBtYXAuX3Rvb2x0aXAuaGlkZSgpO1xuICAgICAgICBtYXAuX2FwcGx5VHJhbnNmb3JtKCk7XG4gICAgICAgIGlmICh0cmFuc1hPbGQgIT0gbWFwLnRyYW5zWCB8fCB0cmFuc1lPbGQgIT0gbWFwLnRyYW5zWSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdG91Y2hYID0gdG91Y2hlc1swXS5wYWdlWDtcbiAgICAgIHRvdWNoWSA9IHRvdWNoZXNbMF0ucGFnZVk7XG4gICAgfSBlbHNlIGlmICh0b3VjaGVzLmxlbmd0aCA9PSAyKSB7XG4gICAgICBpZiAobGFzdFRvdWNoZXNMZW5ndGggPT0gMikge1xuICAgICAgICBzY2FsZSA9IE1hdGguc3FydChNYXRoLnBvdyh0b3VjaGVzWzBdLnBhZ2VYIC0gdG91Y2hlc1sxXS5wYWdlWCwgMikgKyBNYXRoLnBvdyh0b3VjaGVzWzBdLnBhZ2VZIC0gdG91Y2hlc1sxXS5wYWdlWSwgMikpIC8gdG91Y2hTdGFydERpc3RhbmNlO1xuICAgICAgICBtYXAuX3NldFNjYWxlKHRvdWNoU3RhcnRTY2FsZSAqIHNjYWxlLCBjZW50ZXJUb3VjaFgsIGNlbnRlclRvdWNoWSk7XG4gICAgICAgIG1hcC5fdG9vbHRpcC5oaWRlKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZWN0ID0gbWFwLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgb2Zmc2V0ID0ge1xuICAgICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWFxuICAgICAgICB9O1xuICAgICAgICBpZiAodG91Y2hlc1swXS5wYWdlWCA+IHRvdWNoZXNbMV0ucGFnZVgpIHtcbiAgICAgICAgICBjZW50ZXJUb3VjaFggPSB0b3VjaGVzWzFdLnBhZ2VYICsgKHRvdWNoZXNbMF0ucGFnZVggLSB0b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2VudGVyVG91Y2hYID0gdG91Y2hlc1swXS5wYWdlWCArICh0b3VjaGVzWzFdLnBhZ2VYIC0gdG91Y2hlc1swXS5wYWdlWCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaGVzWzBdLnBhZ2VZID4gdG91Y2hlc1sxXS5wYWdlWSkge1xuICAgICAgICAgIGNlbnRlclRvdWNoWSA9IHRvdWNoZXNbMV0ucGFnZVkgKyAodG91Y2hlc1swXS5wYWdlWSAtIHRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjZW50ZXJUb3VjaFkgPSB0b3VjaGVzWzBdLnBhZ2VZICsgKHRvdWNoZXNbMV0ucGFnZVkgLSB0b3VjaGVzWzBdLnBhZ2VZKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgY2VudGVyVG91Y2hYIC09IG9mZnNldC5sZWZ0O1xuICAgICAgICBjZW50ZXJUb3VjaFkgLT0gb2Zmc2V0LnRvcDtcbiAgICAgICAgdG91Y2hTdGFydFNjYWxlID0gbWFwLnNjYWxlO1xuICAgICAgICB0b3VjaFN0YXJ0RGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codG91Y2hlc1swXS5wYWdlWCAtIHRvdWNoZXNbMV0ucGFnZVgsIDIpICsgTWF0aC5wb3codG91Y2hlc1swXS5wYWdlWSAtIHRvdWNoZXNbMV0ucGFnZVksIDIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdFRvdWNoZXNMZW5ndGggPSB0b3VjaGVzLmxlbmd0aDtcbiAgfTtcbiAgRXZlbnRIYW5kbGVyLm9uKG1hcC5jb250YWluZXIsICd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2hFdmVudCk7XG4gIEV2ZW50SGFuZGxlci5vbihtYXAuY29udGFpbmVyLCAndG91Y2htb3ZlJywgaGFuZGxlVG91Y2hFdmVudCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHtcbiAgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpO1xuICBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UociwgZSkge1xuICB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmICh0KSByZXR1cm4gKHQgPSB0LmNhbGwocikpLm5leHQuYmluZCh0KTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikpIHx8IGUgJiYgciAmJiBcIm51bWJlclwiID09IHR5cGVvZiByLmxlbmd0aCkge1xuICAgIHQgJiYgKHIgPSB0KTtcbiAgICB2YXIgbyA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvID49IHIubGVuZ3RoID8ge1xuICAgICAgICBkb25lOiAhMFxuICAgICAgfSA6IHtcbiAgICAgICAgZG9uZTogITEsXG4gICAgICAgIHZhbHVlOiByW28rK11cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKG4pIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHNbZV07XG4gICAgICBmb3IgKHZhciByIGluIHQpICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiAobltyXSA9IHRbcl0pO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfSwgX2V4dGVuZHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHQsIG8pIHtcbiAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG8ucHJvdG90eXBlKSwgdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSB0LCBfc2V0UHJvdG90eXBlT2YodCwgbyk7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDtcbiAgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHtcbiAgaWYgKHIpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpO1xuICAgIHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7XG4gICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG52YXIgQmFzZUNvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VDb21wb25lbnQoKSB7fVxuICB2YXIgX3Byb3RvID0gQmFzZUNvbXBvbmVudC5wcm90b3R5cGU7XG4gIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fdG9vbHRpcCkge1xuICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLl90b29sdGlwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRvZG86IG1vdmUgc2hhcGUgaW4gYmFzZSBjb21wb25lbnQgaW4gdjJcbiAgICAgIHRoaXMuc2hhcGUucmVtb3ZlKCk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBCYXNlQ29tcG9uZW50O1xufSgpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSW50ZXJhY3RhYmxlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xudmFyIEludGVyYWN0YWJsZSA9IHtcbiAgZ2V0TGFiZWxUZXh0OiBmdW5jdGlvbiBnZXRMYWJlbFRleHQoa2V5LCBsYWJlbCkge1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsYWJlbC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgICAgLy8gUGFzcyBhZGRpdGlvbmFsIHBhcmFtYXRlciAoTWFya2VyIGNvbmZpZyBvYmplY3QpIGluIGNhc2UgaXQncyBhIE1hcmtlci5cbiAgICAgIGlmICh0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5tYXJrZXIpIHtcbiAgICAgICAgcGFyYW1zLnB1c2godGhpcy5jb25maWcubWFya2VyKTtcbiAgICAgIH1cblxuICAgICAgLy8gQmVjdWFzZSB3ZSBuZWVkIHRvIGFkZCB0aGUga2V5IGFsd2F5cyBhdCB0aGUgZW5kXG4gICAgICBwYXJhbXMucHVzaChrZXkpO1xuICAgICAgcmV0dXJuIGxhYmVsLnJlbmRlci5hcHBseSh0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9LFxuICBnZXRMYWJlbE9mZnNldHM6IGZ1bmN0aW9uIGdldExhYmVsT2Zmc2V0cyhrZXksIGxhYmVsKSB7XG4gICAgaWYgKHR5cGVvZiBsYWJlbC5vZmZzZXRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbGFiZWwub2Zmc2V0cyhrZXkpO1xuICAgIH1cblxuICAgIC8vIElmIG9mZnNldHMgYXJlIGFuIGFycmF5IG9mIG9mZnNldHMgZS5nIG9mZnNldHM6IFsgWzAsIDI1XSwgWzEwLCAxNV0gXVxuICAgIGlmIChBcnJheS5pc0FycmF5KGxhYmVsLm9mZnNldHMpKSB7XG4gICAgICByZXR1cm4gbGFiZWwub2Zmc2V0c1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIDBdO1xuICB9LFxuICBzZXRTdHlsZTogZnVuY3Rpb24gc2V0U3R5bGUocHJvcGVydHksIHZhbHVlKSB7XG4gICAgdGhpcy5zaGFwZS5zZXRTdHlsZShwcm9wZXJ0eSwgdmFsdWUpO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICB0aGlzLnNoYXBlLnJlbW92ZSgpO1xuICAgIGlmICh0aGlzLmxhYmVsKSB0aGlzLmxhYmVsLnJlbW92ZSgpO1xuICB9LFxuICBob3ZlcjogZnVuY3Rpb24gaG92ZXIoc3RhdGUpIHtcbiAgICB0aGlzLl9zZXRTdGF0dXMoJ2lzSG92ZXJlZCcsIHN0YXRlKTtcbiAgfSxcbiAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3Qoc3RhdGUpIHtcbiAgICB0aGlzLl9zZXRTdGF0dXMoJ2lzU2VsZWN0ZWQnLCBzdGF0ZSk7XG4gIH0sXG4gIC8vIFByaXZhdGVcbiAgX3NldFN0YXR1czogZnVuY3Rpb24gX3NldFN0YXR1cyhwcm9wZXJ0eSwgc3RhdGUpIHtcbiAgICB0aGlzLnNoYXBlW3Byb3BlcnR5XSA9IHN0YXRlO1xuICAgIHRoaXMuc2hhcGUudXBkYXRlU3R5bGUoKTtcbiAgICB0aGlzW3Byb3BlcnR5XSA9IHN0YXRlO1xuICAgIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgICB0aGlzLmxhYmVsW3Byb3BlcnR5XSA9IHN0YXRlO1xuICAgICAgdGhpcy5sYWJlbC51cGRhdGVTdHlsZSgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG52YXIgUmVnaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBSZWdpb24oX3JlZikge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgbWFwID0gX3JlZi5tYXAsXG4gICAgICBjb2RlID0gX3JlZi5jb2RlLFxuICAgICAgcGF0aCA9IF9yZWYucGF0aCxcbiAgICAgIHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGxhYmVsU3R5bGUgPSBfcmVmLmxhYmVsU3R5bGUsXG4gICAgICBsYWJlbHNHcm91cCA9IF9yZWYubGFiZWxzR3JvdXA7XG4gICAgX3RoaXMgPSBfQmFzZUNvbXBvbmVudC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX21hcCA9IG1hcDtcbiAgICBfdGhpcy5zaGFwZSA9IF90aGlzLl9jcmVhdGVSZWdpb24ocGF0aCwgY29kZSwgc3R5bGUpO1xuICAgIHZhciB0ZXh0ID0gX3RoaXMuZ2V0TGFiZWxUZXh0KGNvZGUsIGxhYmVsKTtcblxuICAgIC8vIElmIGxhYmVsIGlzIHBhc3NlZCBhbmQgcmVuZGVyIGZ1bmN0aW9uIHJldHVybnMgc29tZXRoaW5nIFxuICAgIGlmIChsYWJlbCAmJiB0ZXh0KSB7XG4gICAgICB2YXIgYmJveCA9IF90aGlzLnNoYXBlLmdldEJCb3goKTtcbiAgICAgIHZhciBvZmZzZXRzID0gX3RoaXMuZ2V0TGFiZWxPZmZzZXRzKGNvZGUsIGxhYmVsKTtcbiAgICAgIF90aGlzLmxhYmVsWCA9IGJib3gueCArIGJib3gud2lkdGggLyAyICsgb2Zmc2V0c1swXTtcbiAgICAgIF90aGlzLmxhYmVsWSA9IGJib3gueSArIGJib3guaGVpZ2h0IC8gMiArIG9mZnNldHNbMV07XG4gICAgICBfdGhpcy5sYWJlbCA9IF90aGlzLl9tYXAuY2FudmFzLmNyZWF0ZVRleHQoe1xuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgYWxpZ25tZW50QmFzZWxpbmU6ICdjZW50cmFsJyxcbiAgICAgICAgZGF0YUNvZGU6IGNvZGUsXG4gICAgICAgIHg6IF90aGlzLmxhYmVsWCxcbiAgICAgICAgeTogX3RoaXMubGFiZWxZXG4gICAgICB9LCBsYWJlbFN0eWxlLCBsYWJlbHNHcm91cCk7XG4gICAgICBfdGhpcy5sYWJlbC5hZGRDbGFzcygnanZtLXJlZ2lvbiBqdm0tZWxlbWVudCcpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzTG9vc2UoUmVnaW9uLCBfQmFzZUNvbXBvbmVudCk7XG4gIHZhciBfcHJvdG8gPSBSZWdpb24ucHJvdG90eXBlO1xuICBfcHJvdG8uX2NyZWF0ZVJlZ2lvbiA9IGZ1bmN0aW9uIF9jcmVhdGVSZWdpb24ocGF0aCwgY29kZSwgc3R5bGUpIHtcbiAgICBwYXRoID0gdGhpcy5fbWFwLmNhbnZhcy5jcmVhdGVQYXRoKHtcbiAgICAgIGQ6IHBhdGgsXG4gICAgICBkYXRhQ29kZTogY29kZVxuICAgIH0sIHN0eWxlKTtcbiAgICBwYXRoLmFkZENsYXNzKCdqdm0tcmVnaW9uIGp2bS1lbGVtZW50Jyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG4gIF9wcm90by51cGRhdGVMYWJlbFBvc2l0aW9uID0gZnVuY3Rpb24gdXBkYXRlTGFiZWxQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgdGhpcy5sYWJlbC5zZXQoe1xuICAgICAgICB4OiB0aGlzLmxhYmVsWCAqIHRoaXMuX21hcC5zY2FsZSArIHRoaXMuX21hcC50cmFuc1ggKiB0aGlzLl9tYXAuc2NhbGUsXG4gICAgICAgIHk6IHRoaXMubGFiZWxZICogdGhpcy5fbWFwLnNjYWxlICsgdGhpcy5fbWFwLnRyYW5zWSAqIHRoaXMuX21hcC5zY2FsZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gUmVnaW9uO1xufShCYXNlQ29tcG9uZW50KTtcbmluaGVyaXQoUmVnaW9uLCBJbnRlcmFjdGFibGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVSZWdpb25zKCkge1xuICB0aGlzLl9yZWdpb25MYWJlbHNHcm91cCA9IHRoaXMuX3JlZ2lvbkxhYmVsc0dyb3VwIHx8IHRoaXMuY2FudmFzLmNyZWF0ZUdyb3VwKCdqdm0tcmVnaW9ucy1sYWJlbHMtZ3JvdXAnKTtcbiAgZm9yICh2YXIgY29kZSBpbiB0aGlzLl9tYXBEYXRhLnBhdGhzKSB7XG4gICAgdmFyIHJlZ2lvbiA9IG5ldyBSZWdpb24oe1xuICAgICAgbWFwOiB0aGlzLFxuICAgICAgY29kZTogY29kZSxcbiAgICAgIHBhdGg6IHRoaXMuX21hcERhdGEucGF0aHNbY29kZV0ucGF0aCxcbiAgICAgIHN0eWxlOiBtZXJnZSh7fSwgdGhpcy5wYXJhbXMucmVnaW9uU3R5bGUpLFxuICAgICAgbGFiZWxTdHlsZTogdGhpcy5wYXJhbXMucmVnaW9uTGFiZWxTdHlsZSxcbiAgICAgIGxhYmVsc0dyb3VwOiB0aGlzLl9yZWdpb25MYWJlbHNHcm91cCxcbiAgICAgIGxhYmVsOiB0aGlzLnBhcmFtcy5sYWJlbHMgJiYgdGhpcy5wYXJhbXMubGFiZWxzLnJlZ2lvbnNcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lvbnNbY29kZV0gPSB7XG4gICAgICBjb25maWc6IHRoaXMuX21hcERhdGEucGF0aHNbY29kZV0sXG4gICAgICBlbGVtZW50OiByZWdpb25cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xudmFyIExpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIExpbmUoX3JlZikge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgaW5kZXggPSBfcmVmLmluZGV4LFxuICAgICAgbWFwID0gX3JlZi5tYXAsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICB4MSA9IF9yZWYueDEsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICB4MiA9IF9yZWYueDIsXG4gICAgICB5MiA9IF9yZWYueTIsXG4gICAgICBncm91cCA9IF9yZWYuZ3JvdXAsXG4gICAgICBjb25maWcgPSBfcmVmLmNvbmZpZztcbiAgICBfdGhpcyA9IF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgX3RoaXMuc2hhcGUgPSBtYXAuY2FudmFzLmNyZWF0ZUxpbmUoe1xuICAgICAgeDE6IHgxLFxuICAgICAgeTE6IHkxLFxuICAgICAgeDI6IHgyLFxuICAgICAgeTI6IHkyLFxuICAgICAgZGF0YUluZGV4OiBpbmRleFxuICAgIH0sIHN0eWxlLCBncm91cCk7XG4gICAgX3RoaXMuc2hhcGUuYWRkQ2xhc3MoJ2p2bS1saW5lJyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0c0xvb3NlKExpbmUsIF9CYXNlQ29tcG9uZW50KTtcbiAgdmFyIF9wcm90byA9IExpbmUucHJvdG90eXBlO1xuICBfcHJvdG8uc2V0U3R5bGUgPSBmdW5jdGlvbiBzZXRTdHlsZShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICB0aGlzLnNoYXBlLnNldFN0eWxlKHByb3BlcnR5LCB2YWx1ZSk7XG4gIH07XG4gIHJldHVybiBMaW5lO1xufShCYXNlQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gY3JlYXRlTGluZXMobGluZXMsIG1hcmtlcnMsIGlzUmVjZW50bHlDcmVhdGVkKSB7XG4gIGlmIChpc1JlY2VudGx5Q3JlYXRlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNSZWNlbnRseUNyZWF0ZWQgPSBmYWxzZTtcbiAgfVxuICB2YXIgcG9pbnQxID0gZmFsc2UsXG4gICAgcG9pbnQyID0gZmFsc2U7XG5cbiAgLy8gQ3JlYXRlIGdyb3VwIGZvciBob2xkaW5nIGxpbmVzXG4gIC8vIHdlJ3JlIGNoZWNraW5nIGlmIGBsaW5lc0dyb3VwYCBleGlzdHMgb3Igbm90IGJlY3Vhc2Ugd2UgbWF5IGFkZCBsaW5lc1xuICAvLyBhZnRlciB0aGUgbWFwIGhhcyBsb2FkZWQgc28gd2Ugd2lsbCBhcHBlbmQgdGhlIGZ1dHVyZWQgbGluZXMgdG8gdGhpcyBncm91cCBhcyB3ZWxsLlxuICB0aGlzLmxpbmVzR3JvdXAgPSB0aGlzLmxpbmVzR3JvdXAgfHwgdGhpcy5jYW52YXMuY3JlYXRlR3JvdXAoJ2p2bS1saW5lcy1ncm91cCcpO1xuICBmb3IgKHZhciBpbmRleCBpbiBsaW5lcykge1xuICAgIHZhciBjb25maWcgPSBsaW5lc1tpbmRleF07XG4gICAgZm9yICh2YXIgbWluZGV4IGluIG1hcmtlcnMpIHtcbiAgICAgIHZhciBtYXJrZXJDb25maWcgPSBpc1JlY2VudGx5Q3JlYXRlZCA/IG1hcmtlcnNbbWluZGV4XS5jb25maWcgOiBtYXJrZXJzW21pbmRleF07XG4gICAgICBpZiAobWFya2VyQ29uZmlnLm5hbWUgPT09IGNvbmZpZy5mcm9tKSB7XG4gICAgICAgIHBvaW50MSA9IHRoaXMuZ2V0TWFya2VyUG9zaXRpb24obWFya2VyQ29uZmlnKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXJrZXJDb25maWcubmFtZSA9PT0gY29uZmlnLnRvKSB7XG4gICAgICAgIHBvaW50MiA9IHRoaXMuZ2V0TWFya2VyUG9zaXRpb24obWFya2VyQ29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvaW50MSAhPT0gZmFsc2UgJiYgcG9pbnQyICE9PSBmYWxzZSkge1xuICAgICAgLy8gUmVnaXN0ZXIgbGluZXMgd2l0aCB1bmlxdWUga2V5c1xuICAgICAgdGhpcy5fbGluZXNbZ2V0TGluZVVpZChjb25maWcuZnJvbSwgY29uZmlnLnRvKV0gPSBuZXcgTGluZSh7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgbWFwOiB0aGlzLFxuICAgICAgICAvLyBNZXJnZSB0aGUgZGVmYXVsdCBgbGluZVN0eWxlYCBvYmplY3Qgd2l0aCB0aGUgY3VzdG9tIGBsaW5lYCBjb25maWcgc3R5bGVcbiAgICAgICAgc3R5bGU6IG1lcmdlKHtcbiAgICAgICAgICBpbml0aWFsOiB0aGlzLnBhcmFtcy5saW5lU3R5bGVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGluaXRpYWw6IGNvbmZpZy5zdHlsZSB8fCB7fVxuICAgICAgICB9LCB0cnVlKSxcbiAgICAgICAgeDE6IHBvaW50MS54LFxuICAgICAgICB5MTogcG9pbnQxLnksXG4gICAgICAgIHgyOiBwb2ludDIueCxcbiAgICAgICAgeTI6IHBvaW50Mi55LFxuICAgICAgICBncm91cDogdGhpcy5saW5lc0dyb3VwLFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xudmFyIE1hcmtlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgZnVuY3Rpb24gTWFya2VyKF9yZWYpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIGluZGV4ID0gX3JlZi5pbmRleCxcbiAgICAgIHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGN4ID0gX3JlZi5jeCxcbiAgICAgIGN5ID0gX3JlZi5jeSxcbiAgICAgIG1hcCA9IF9yZWYubWFwLFxuICAgICAgZ3JvdXAgPSBfcmVmLmdyb3VwO1xuICAgIF90aGlzID0gX0Jhc2VDb21wb25lbnQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF90aGlzLl9tYXAgPSBtYXA7XG4gICAgX3RoaXMuX2lzSW1hZ2UgPSAhIXN0eWxlLmluaXRpYWwuaW1hZ2U7XG5cbiAgICAvLyBQcm90ZWN0ZWRcbiAgICBfdGhpcy5jb25maWcgPSBhcmd1bWVudHNbMF07XG4gICAgX3RoaXMuc2hhcGUgPSBtYXAuY2FudmFzW190aGlzLl9pc0ltYWdlID8gJ2NyZWF0ZUltYWdlJyA6ICdjcmVhdGVDaXJjbGUnXSh7XG4gICAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgICAgY3g6IGN4LFxuICAgICAgY3k6IGN5XG4gICAgfSwgc3R5bGUsIGdyb3VwKTtcbiAgICBfdGhpcy5zaGFwZS5hZGRDbGFzcygnanZtLW1hcmtlciBqdm0tZWxlbWVudCcpO1xuICAgIGlmIChfdGhpcy5faXNJbWFnZSkge1xuICAgICAgX3RoaXMudXBkYXRlTGFiZWxQb3NpdGlvbigpO1xuICAgIH1cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIF90aGlzLl9jcmVhdGVMYWJlbChfdGhpcy5jb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzTG9vc2UoTWFya2VyLCBfQmFzZUNvbXBvbmVudCk7XG4gIHZhciBfcHJvdG8gPSBNYXJrZXIucHJvdG90eXBlO1xuICBfcHJvdG8udXBkYXRlTGFiZWxQb3NpdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgIHRoaXMubGFiZWwuc2V0KHtcbiAgICAgICAgeDogdGhpcy5fbGFiZWxYICogdGhpcy5fbWFwLnNjYWxlICsgdGhpcy5fb2Zmc2V0c1swXSArIHRoaXMuX21hcC50cmFuc1ggKiB0aGlzLl9tYXAuc2NhbGUgKyA1ICsgKHRoaXMuX2lzSW1hZ2UgPyAodGhpcy5zaGFwZS53aWR0aCB8fCAwKSAvIDIgOiB0aGlzLnNoYXBlLm5vZGUuci5iYXNlVmFsLnZhbHVlKSxcbiAgICAgICAgeTogdGhpcy5fbGFiZWxZICogdGhpcy5fbWFwLnNjYWxlICsgdGhpcy5fbWFwLnRyYW5zWSAqIHRoaXMuX21hcC5zY2FsZSArIHRoaXMuX29mZnNldHNbMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLl9jcmVhdGVMYWJlbCA9IGZ1bmN0aW9uIF9jcmVhdGVMYWJlbChfcmVmMikge1xuICAgIHZhciBpbmRleCA9IF9yZWYyLmluZGV4LFxuICAgICAgbWFwID0gX3JlZjIubWFwLFxuICAgICAgbGFiZWwgPSBfcmVmMi5sYWJlbCxcbiAgICAgIGxhYmVsc0dyb3VwID0gX3JlZjIubGFiZWxzR3JvdXAsXG4gICAgICBjeCA9IF9yZWYyLmN4LFxuICAgICAgY3kgPSBfcmVmMi5jeSxcbiAgICAgIG1hcmtlciA9IF9yZWYyLm1hcmtlcixcbiAgICAgIGlzUmVjZW50bHlDcmVhdGVkID0gX3JlZjIuaXNSZWNlbnRseUNyZWF0ZWQ7XG4gICAgdmFyIGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGluZGV4LCBsYWJlbCk7XG4gICAgdGhpcy5fbGFiZWxYID0gY3ggLyBtYXAuc2NhbGUgLSBtYXAudHJhbnNYO1xuICAgIHRoaXMuX2xhYmVsWSA9IGN5IC8gbWFwLnNjYWxlIC0gbWFwLnRyYW5zWTtcbiAgICB0aGlzLl9vZmZzZXRzID0gaXNSZWNlbnRseUNyZWF0ZWQgJiYgbWFya2VyLm9mZnNldHMgPyBtYXJrZXIub2Zmc2V0cyA6IHRoaXMuZ2V0TGFiZWxPZmZzZXRzKGluZGV4LCBsYWJlbCk7XG4gICAgdGhpcy5sYWJlbCA9IG1hcC5jYW52YXMuY3JlYXRlVGV4dCh7XG4gICAgICB0ZXh0OiBsYWJlbFRleHQsXG4gICAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgICAgeDogdGhpcy5fbGFiZWxYLFxuICAgICAgeTogdGhpcy5fbGFiZWxZLFxuICAgICAgZHk6ICcwLjZleCdcbiAgICB9LCBtYXAucGFyYW1zLm1hcmtlckxhYmVsU3R5bGUsIGxhYmVsc0dyb3VwKTtcbiAgICB0aGlzLmxhYmVsLmFkZENsYXNzKCdqdm0tbWFya2VyIGp2bS1lbGVtZW50Jyk7XG4gICAgaWYgKGlzUmVjZW50bHlDcmVhdGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsUG9zaXRpb24oKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBNYXJrZXI7XG59KEJhc2VDb21wb25lbnQpO1xuaW5oZXJpdChNYXJrZXIsIEludGVyYWN0YWJsZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmtlcnMobWFya2VycywgaXNSZWNlbnRseUNyZWF0ZWQpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgaWYgKG1hcmtlcnMgPT09IHZvaWQgMCkge1xuICAgIG1hcmtlcnMgPSB7fTtcbiAgfVxuICBpZiAoaXNSZWNlbnRseUNyZWF0ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzUmVjZW50bHlDcmVhdGVkID0gZmFsc2U7XG4gIH1cbiAgLy8gQ3JlYXRlIGdyb3VwcyBmb3IgaG9sZGluZyBtYXJrZXJzIGFuZCBtYXJrZXJzIGxhYmVsc1xuICAvLyBXZSdyZSBjaGVja2luZyBpZiBgbWFya2Vyc0dyb3VwYCBleGlzdHMgb3Igbm90IGJlY3Vhc2Ugd2UgbWF5IGFkZCBtYXJrZXJzIGFmdGVyIHRoZSBtYXAgaGFzIGxvYWRlZFxuICAvLyBTbyB3ZSB3aWxsIGFwcGVuZCB0aGUgZnV0dXJlZCBtYXJrZXJzIHRvIHRoaXMgZ3JvdXAgYXMgd2VsbC5cbiAgdGhpcy5fbWFya2Vyc0dyb3VwID0gdGhpcy5fbWFya2Vyc0dyb3VwIHx8IHRoaXMuY2FudmFzLmNyZWF0ZUdyb3VwKCdqdm0tbWFya2Vycy1ncm91cCcpO1xuICB0aGlzLl9tYXJrZXJMYWJlbHNHcm91cCA9IHRoaXMuX21hcmtlckxhYmVsc0dyb3VwIHx8IHRoaXMuY2FudmFzLmNyZWF0ZUdyb3VwKCdqdm0tbWFya2Vycy1sYWJlbHMtZ3JvdXAnKTtcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgY29uZmlnID0gbWFya2Vyc1tpbmRleF07XG4gICAgICB2YXIgcG9pbnQgPSBfdGhpcy5nZXRNYXJrZXJQb3NpdGlvbihjb25maWcpO1xuICAgICAgdmFyIHVpZCA9IGNvbmZpZy5jb29yZHMuam9pbignOicpO1xuICAgICAgaWYgKCFwb2ludCkge1xuICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gV2UncmUgY2hlY2tpbmcgaWYgcmVjZW50bHkgY3JlYXRlZCBtYXJrZXIgZG9lcyBhbHJlYWR5IGV4aXN0XG4gICAgICAvLyBJZiBpdCBkb2VzIHdlIGRvbid0IG5lZWQgdG8gY3JlYXRlIGl0IGFnYWluLCBzbyB3ZSdsbCBjb250aW51ZVxuICAgICAgLy8gQmVjdWFzZSB3ZSBtYXkgaGF2ZSBtb3JlIHRoYW4gb25lIG1hcmtlciBzdWJtaXR0ZWQgdmlhIGBhZGRNYXJrZXJzYCBtZXRob2QuXG4gICAgICBpZiAoaXNSZWNlbnRseUNyZWF0ZWQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKF90aGlzLl9tYXJrZXJzKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcmtlcnNbaV0uX3VpZCA9PT0gdWlkO1xuICAgICAgICB9KS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IE9iamVjdC5rZXlzKF90aGlzLl9tYXJrZXJzKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgbWFya2VyID0gbmV3IE1hcmtlcih7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgbWFwOiBfdGhpcyxcbiAgICAgICAgLy8gTWVyZ2UgdGhlIGBtYXJrZXJTdHlsZWAgb2JqZWN0IHdpdGggdGhlIG1hcmtlciBjb25maWcgYHN0eWxlYCBpZiBwcmVzZW50ZWQuXG4gICAgICAgIHN0eWxlOiBtZXJnZShfdGhpcy5wYXJhbXMubWFya2VyU3R5bGUsIF9leHRlbmRzKHt9LCBjb25maWcuc3R5bGUgfHwge30pLCB0cnVlKSxcbiAgICAgICAgbGFiZWw6IF90aGlzLnBhcmFtcy5sYWJlbHMgJiYgX3RoaXMucGFyYW1zLmxhYmVscy5tYXJrZXJzLFxuICAgICAgICBsYWJlbHNHcm91cDogX3RoaXMuX21hcmtlckxhYmVsc0dyb3VwLFxuICAgICAgICBjeDogcG9pbnQueCxcbiAgICAgICAgY3k6IHBvaW50LnksXG4gICAgICAgIGdyb3VwOiBfdGhpcy5fbWFya2Vyc0dyb3VwLFxuICAgICAgICBtYXJrZXI6IGNvbmZpZyxcbiAgICAgICAgaXNSZWNlbnRseUNyZWF0ZWQ6IGlzUmVjZW50bHlDcmVhdGVkXG4gICAgICB9KTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIG1hcmtlciBkdXBsaWNhdGlvblxuICAgICAgLy8gdGhpcyBpcyB1c2VmdWwgd2hlbiBmb3IgZXhhbXBsZTogYSB1c2VyIGNsaWNrcyBhIGJ1dHRvbiBmb3IgY3JlYXRpbmcgbWFya2VyIHR3byB0aW1lc1xuICAgICAgLy8gc28gaXQgd2lsbCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIHRoZSBuZXcgb25lIHdpbGwgdGFrZSBpdHMgcGxhY2UuXG4gICAgICBpZiAoX3RoaXMuX21hcmtlcnNbaW5kZXhdKSB7XG4gICAgICAgIF90aGlzLnJlbW92ZU1hcmtlcnMoW2luZGV4XSk7XG4gICAgICB9XG4gICAgICBfdGhpcy5fbWFya2Vyc1tpbmRleF0gPSB7XG4gICAgICAgIF91aWQ6IHVpZCxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIGVsZW1lbnQ6IG1hcmtlclxuICAgICAgfTtcbiAgICB9LFxuICAgIF9yZXQ7XG4gIGZvciAodmFyIGluZGV4IGluIG1hcmtlcnMpIHtcbiAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICBpZiAoX3JldCA9PT0gMCkgY29udGludWU7XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG52YXIgTGVnZW5kID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGVnZW5kKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX21hcCA9IHRoaXMuX29wdGlvbnMubWFwO1xuICAgIHRoaXMuX3NlcmllcyA9IHRoaXMuX29wdGlvbnMuc2VyaWVzO1xuICAgIHRoaXMuX2JvZHkgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCAnanZtLWxlZ2VuZCcpO1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmNzc0NsYXNzKSB7XG4gICAgICB0aGlzLl9ib2R5LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLl9vcHRpb25zLmNzc0NsYXNzKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudmVydGljYWwpIHtcbiAgICAgIHRoaXMuX21hcC5sZWdlbmRWZXJ0aWNhbC5hcHBlbmRDaGlsZCh0aGlzLl9ib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWFwLmxlZ2VuZEhvcml6b250YWwuYXBwZW5kQ2hpbGQodGhpcy5fYm9keSk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgdmFyIF9wcm90byA9IExlZ2VuZC5wcm90b3R5cGU7XG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHRpY2tzID0gdGhpcy5fc2VyaWVzLnNjYWxlLmdldFRpY2tzKCk7XG4gICAgdmFyIGlubmVyID0gY3JlYXRlRWxlbWVudCgnZGl2JywgJ2p2bS1sZWdlbmQtaW5uZXInKTtcbiAgICB0aGlzLl9ib2R5LmlubmRlckhUTUwgPSAnJztcbiAgICBpZiAodGhpcy5fb3B0aW9ucy50aXRsZSkge1xuICAgICAgdmFyIGxlZ2VuZFRpdGxlID0gY3JlYXRlRWxlbWVudCgnZGl2JywgJ2p2bS1sZWdlbmQtdGl0bGUnLCB0aGlzLl9vcHRpb25zLnRpdGxlKTtcbiAgICAgIHRoaXMuX2JvZHkuYXBwZW5kQ2hpbGQobGVnZW5kVGl0bGUpO1xuICAgIH1cbiAgICB0aGlzLl9ib2R5LmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGljayA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsICdqdm0tbGVnZW5kLXRpY2snKTtcbiAgICAgIHZhciBzYW1wbGUgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCAnanZtLWxlZ2VuZC10aWNrLXNhbXBsZScpO1xuICAgICAgc3dpdGNoICh0aGlzLl9zZXJpZXMuY29uZmlnLmF0dHJpYnV0ZSkge1xuICAgICAgICBjYXNlICdmaWxsJzpcbiAgICAgICAgICBpZiAoaXNJbWFnZVVybCh0aWNrc1tpXS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHNhbXBsZS5zdHlsZS5iYWNrZ3JvdW5kID0gXCJ1cmwoXCIgKyB0aWNrc1tpXS52YWx1ZSArIFwiKVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYW1wbGUuc3R5bGUuYmFja2dyb3VuZCA9IHRpY2tzW2ldLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Ryb2tlJzpcbiAgICAgICAgICBzYW1wbGUuc3R5bGUuYmFja2dyb3VuZCA9IHRpY2tzW2ldLnZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgc2FtcGxlLnN0eWxlLmJhY2tncm91bmQgPSBcInVybChcIiArICh0eXBlb2YgdGlja3NbaV0udmFsdWUgPT09ICdvYmplY3QnID8gdGlja3NbaV0udmFsdWUudXJsIDogdGlja3NbaV0udmFsdWUpICsgXCIpIG5vLXJlcGVhdCBjZW50ZXIgY2VudGVyXCI7XG4gICAgICAgICAgc2FtcGxlLnN0eWxlLmJhY2tncm91bmRTaXplID0gJ2NvdmVyJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRpY2suYXBwZW5kQ2hpbGQoc2FtcGxlKTtcbiAgICAgIHZhciBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMubGFiZWxSZW5kZXIpIHtcbiAgICAgICAgbGFiZWwgPSB0aGlzLl9vcHRpb25zLmxhYmVsUmVuZGVyKGxhYmVsKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aWNrVGV4dCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsICdqdm0tbGVnZW5kLXRpY2stdGV4dCcsIGxhYmVsKTtcbiAgICAgIHRpY2suYXBwZW5kQ2hpbGQodGlja1RleHQpO1xuICAgICAgaW5uZXIuYXBwZW5kQ2hpbGQodGljayk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gTGVnZW5kO1xufSgpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbnZhciBPcmRpbmFsU2NhbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPcmRpbmFsU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLl9zY2FsZSA9IHNjYWxlO1xuICB9XG4gIHZhciBfcHJvdG8gPSBPcmRpbmFsU2NhbGUucHJvdG90eXBlO1xuICBfcHJvdG8uZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9zY2FsZVt2YWx1ZV07XG4gIH07XG4gIF9wcm90by5nZXRUaWNrcyA9IGZ1bmN0aW9uIGdldFRpY2tzKCkge1xuICAgIHZhciB0aWNrcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9zY2FsZSkge1xuICAgICAgdGlja3MucHVzaCh7XG4gICAgICAgIGxhYmVsOiBrZXksXG4gICAgICAgIHZhbHVlOiB0aGlzLl9zY2FsZVtrZXldXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9O1xuICByZXR1cm4gT3JkaW5hbFNjYWxlO1xufSgpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbnZhciBTZXJpZXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXJpZXMoY29uZmlnLCBlbGVtZW50cywgbWFwKSB7XG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbGVtZW50cyA9IGVsZW1lbnRzOyAvLyBDb3VsZCBiZSBtYXJrZXJzIG9yIHJlZ2lvbnNcbiAgICB0aGlzLl92YWx1ZXMgPSBjb25maWcudmFsdWVzIHx8IHt9O1xuXG4gICAgLy8gUHJvdGVjdGVkXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jb25maWcuYXR0cmlidXRlID0gY29uZmlnLmF0dHJpYnV0ZSB8fCAnZmlsbCc7XG5cbiAgICAvLyBTZXQgaW5pdGlhbCBhdHRyaWJ1dGVzXG4gICAgaWYgKGNvbmZpZy5hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoY29uZmlnLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5zY2FsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuc2NhbGUgPSBuZXcgT3JkaW5hbFNjYWxlKGNvbmZpZy5zY2FsZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5sZWdlbmQpIHtcbiAgICAgIHRoaXMubGVnZW5kID0gbmV3IExlZ2VuZChtZXJnZSh7XG4gICAgICAgIG1hcDogdGhpcy5fbWFwLFxuICAgICAgICBzZXJpZXM6IHRoaXNcbiAgICAgIH0sIHRoaXMuY29uZmlnLmxlZ2VuZCkpO1xuICAgIH1cbiAgICB0aGlzLnNldFZhbHVlcyh0aGlzLl92YWx1ZXMpO1xuICB9XG4gIHZhciBfcHJvdG8gPSBTZXJpZXMucHJvdG90eXBlO1xuICBfcHJvdG8uc2V0VmFsdWVzID0gZnVuY3Rpb24gc2V0VmFsdWVzKHZhbHVlcykge1xuICAgIHZhciBhdHRycyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXNba2V5XSkge1xuICAgICAgICBhdHRyc1trZXldID0gdGhpcy5zY2FsZS5nZXRWYWx1ZSh2YWx1ZXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0QXR0cmlidXRlcyhhdHRycyk7XG4gIH07XG4gIF9wcm90by5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhhdHRycykge1xuICAgIGZvciAodmFyIGNvZGUgaW4gYXR0cnMpIHtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50c1tjb2RlXSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50c1tjb2RlXS5lbGVtZW50LnNldFN0eWxlKHRoaXMuY29uZmlnLmF0dHJpYnV0ZSwgYXR0cnNbY29kZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIGtleSxcbiAgICAgIGF0dHJzID0ge307XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fdmFsdWVzKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudHNba2V5XSkge1xuICAgICAgICBhdHRyc1trZXldID0gdGhpcy5fZWxlbWVudHNba2V5XS5lbGVtZW50LnNoYXBlLnN0eWxlLmluaXRpYWxbdGhpcy5jb25maWcuYXR0cmlidXRlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVzKGF0dHJzKTtcbiAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgfTtcbiAgcmV0dXJuIFNlcmllcztcbn0oKTtcblxuZnVuY3Rpb24gY3JlYXRlU2VyaWVzKCkge1xuICB0aGlzLnNlcmllcyA9IHtcbiAgICBtYXJrZXJzOiBbXSxcbiAgICByZWdpb25zOiBbXVxuICB9O1xuICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wYXJhbXMuc2VyaWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcmFtcy5zZXJpZXNba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zZXJpZXNba2V5XVtpXSA9IG5ldyBTZXJpZXModGhpcy5wYXJhbXMuc2VyaWVzW2tleV1baV0sIGtleSA9PT0gJ21hcmtlcnMnID8gdGhpcy5fbWFya2VycyA6IHRoaXMucmVnaW9ucywgdGhpcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKCkge1xuICB2YXIgbWF4VHJhbnNYLCBtYXhUcmFuc1ksIG1pblRyYW5zWCwgbWluVHJhbnNZO1xuICBpZiAodGhpcy5fZGVmYXVsdFdpZHRoICogdGhpcy5zY2FsZSA8PSB0aGlzLl93aWR0aCkge1xuICAgIG1heFRyYW5zWCA9ICh0aGlzLl93aWR0aCAtIHRoaXMuX2RlZmF1bHRXaWR0aCAqIHRoaXMuc2NhbGUpIC8gKDIgKiB0aGlzLnNjYWxlKTtcbiAgICBtaW5UcmFuc1ggPSAodGhpcy5fd2lkdGggLSB0aGlzLl9kZWZhdWx0V2lkdGggKiB0aGlzLnNjYWxlKSAvICgyICogdGhpcy5zY2FsZSk7XG4gIH0gZWxzZSB7XG4gICAgbWF4VHJhbnNYID0gMDtcbiAgICBtaW5UcmFuc1ggPSAodGhpcy5fd2lkdGggLSB0aGlzLl9kZWZhdWx0V2lkdGggKiB0aGlzLnNjYWxlKSAvIHRoaXMuc2NhbGU7XG4gIH1cbiAgaWYgKHRoaXMuX2RlZmF1bHRIZWlnaHQgKiB0aGlzLnNjYWxlIDw9IHRoaXMuX2hlaWdodCkge1xuICAgIG1heFRyYW5zWSA9ICh0aGlzLl9oZWlnaHQgLSB0aGlzLl9kZWZhdWx0SGVpZ2h0ICogdGhpcy5zY2FsZSkgLyAoMiAqIHRoaXMuc2NhbGUpO1xuICAgIG1pblRyYW5zWSA9ICh0aGlzLl9oZWlnaHQgLSB0aGlzLl9kZWZhdWx0SGVpZ2h0ICogdGhpcy5zY2FsZSkgLyAoMiAqIHRoaXMuc2NhbGUpO1xuICB9IGVsc2Uge1xuICAgIG1heFRyYW5zWSA9IDA7XG4gICAgbWluVHJhbnNZID0gKHRoaXMuX2hlaWdodCAtIHRoaXMuX2RlZmF1bHRIZWlnaHQgKiB0aGlzLnNjYWxlKSAvIHRoaXMuc2NhbGU7XG4gIH1cbiAgaWYgKHRoaXMudHJhbnNZID4gbWF4VHJhbnNZKSB7XG4gICAgdGhpcy50cmFuc1kgPSBtYXhUcmFuc1k7XG4gIH0gZWxzZSBpZiAodGhpcy50cmFuc1kgPCBtaW5UcmFuc1kpIHtcbiAgICB0aGlzLnRyYW5zWSA9IG1pblRyYW5zWTtcbiAgfVxuICBpZiAodGhpcy50cmFuc1ggPiBtYXhUcmFuc1gpIHtcbiAgICB0aGlzLnRyYW5zWCA9IG1heFRyYW5zWDtcbiAgfSBlbHNlIGlmICh0aGlzLnRyYW5zWCA8IG1pblRyYW5zWCkge1xuICAgIHRoaXMudHJhbnNYID0gbWluVHJhbnNYO1xuICB9XG4gIHRoaXMuY2FudmFzLmFwcGx5VHJhbnNmb3JtUGFyYW1zKHRoaXMuc2NhbGUsIHRoaXMudHJhbnNYLCB0aGlzLnRyYW5zWSk7XG4gIGlmICh0aGlzLl9tYXJrZXJzKSB7XG4gICAgdGhpcy5fcmVwb3NpdGlvbk1hcmtlcnMoKTtcbiAgfVxuICBpZiAodGhpcy5fbGluZXMpIHtcbiAgICB0aGlzLl9yZXBvc2l0aW9uTGluZXMoKTtcbiAgfVxuICB0aGlzLl9yZXBvc2l0aW9uTGFiZWxzKCk7XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgdmFyIGN1ckJhc2VTY2FsZSA9IHRoaXMuX2Jhc2VTY2FsZTtcbiAgaWYgKHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0ID4gdGhpcy5fZGVmYXVsdFdpZHRoIC8gdGhpcy5fZGVmYXVsdEhlaWdodCkge1xuICAgIHRoaXMuX2Jhc2VTY2FsZSA9IHRoaXMuX2hlaWdodCAvIHRoaXMuX2RlZmF1bHRIZWlnaHQ7XG4gICAgdGhpcy5fYmFzZVRyYW5zWCA9IE1hdGguYWJzKHRoaXMuX3dpZHRoIC0gdGhpcy5fZGVmYXVsdFdpZHRoICogdGhpcy5fYmFzZVNjYWxlKSAvICgyICogdGhpcy5fYmFzZVNjYWxlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9iYXNlU2NhbGUgPSB0aGlzLl93aWR0aCAvIHRoaXMuX2RlZmF1bHRXaWR0aDtcbiAgICB0aGlzLl9iYXNlVHJhbnNZID0gTWF0aC5hYnModGhpcy5faGVpZ2h0IC0gdGhpcy5fZGVmYXVsdEhlaWdodCAqIHRoaXMuX2Jhc2VTY2FsZSkgLyAoMiAqIHRoaXMuX2Jhc2VTY2FsZSk7XG4gIH1cbiAgdGhpcy5zY2FsZSAqPSB0aGlzLl9iYXNlU2NhbGUgLyBjdXJCYXNlU2NhbGU7XG4gIHRoaXMudHJhbnNYICo9IHRoaXMuX2Jhc2VTY2FsZSAvIGN1ckJhc2VTY2FsZTtcbiAgdGhpcy50cmFuc1kgKj0gdGhpcy5fYmFzZVNjYWxlIC8gY3VyQmFzZVNjYWxlO1xufVxuXG5mdW5jdGlvbiBzZXRTY2FsZShzY2FsZSwgYW5jaG9yWCwgYW5jaG9yWSwgaXNDZW50ZXJlZCwgYW5pbWF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgem9vbVN0ZXAsXG4gICAgaW50ZXJ2YWwsXG4gICAgaSA9IDAsXG4gICAgY291bnQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKChzY2FsZSAtIHRoaXMuc2NhbGUpICogNjAgLyBNYXRoLm1heChzY2FsZSwgdGhpcy5zY2FsZSkpKSxcbiAgICBzY2FsZVN0YXJ0LFxuICAgIHNjYWxlRGlmZixcbiAgICB0cmFuc1hTdGFydCxcbiAgICB0cmFuc1hEaWZmLFxuICAgIHRyYW5zWVN0YXJ0LFxuICAgIHRyYW5zWURpZmYsXG4gICAgdHJhbnNYLFxuICAgIHRyYW5zWTtcbiAgaWYgKHNjYWxlID4gdGhpcy5wYXJhbXMuem9vbU1heCAqIHRoaXMuX2Jhc2VTY2FsZSkge1xuICAgIHNjYWxlID0gdGhpcy5wYXJhbXMuem9vbU1heCAqIHRoaXMuX2Jhc2VTY2FsZTtcbiAgfSBlbHNlIGlmIChzY2FsZSA8IHRoaXMucGFyYW1zLnpvb21NaW4gKiB0aGlzLl9iYXNlU2NhbGUpIHtcbiAgICBzY2FsZSA9IHRoaXMucGFyYW1zLnpvb21NaW4gKiB0aGlzLl9iYXNlU2NhbGU7XG4gIH1cbiAgaWYgKHR5cGVvZiBhbmNob3JYICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBhbmNob3JZICE9ICd1bmRlZmluZWQnKSB7XG4gICAgem9vbVN0ZXAgPSBzY2FsZSAvIHRoaXMuc2NhbGU7XG4gICAgaWYgKGlzQ2VudGVyZWQpIHtcbiAgICAgIHRyYW5zWCA9IGFuY2hvclggKyB0aGlzLl9kZWZhdWx0V2lkdGggKiAodGhpcy5fd2lkdGggLyAodGhpcy5fZGVmYXVsdFdpZHRoICogc2NhbGUpKSAvIDI7XG4gICAgICB0cmFuc1kgPSBhbmNob3JZICsgdGhpcy5fZGVmYXVsdEhlaWdodCAqICh0aGlzLl9oZWlnaHQgLyAodGhpcy5fZGVmYXVsdEhlaWdodCAqIHNjYWxlKSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc1ggPSB0aGlzLnRyYW5zWCAtICh6b29tU3RlcCAtIDEpIC8gc2NhbGUgKiBhbmNob3JYO1xuICAgICAgdHJhbnNZID0gdGhpcy50cmFuc1kgLSAoem9vbVN0ZXAgLSAxKSAvIHNjYWxlICogYW5jaG9yWTtcbiAgICB9XG4gIH1cbiAgaWYgKGFuaW1hdGUgJiYgY291bnQgPiAwKSB7XG4gICAgc2NhbGVTdGFydCA9IHRoaXMuc2NhbGU7XG4gICAgc2NhbGVEaWZmID0gKHNjYWxlIC0gc2NhbGVTdGFydCkgLyBjb3VudDtcbiAgICB0cmFuc1hTdGFydCA9IHRoaXMudHJhbnNYICogdGhpcy5zY2FsZTtcbiAgICB0cmFuc1lTdGFydCA9IHRoaXMudHJhbnNZICogdGhpcy5zY2FsZTtcbiAgICB0cmFuc1hEaWZmID0gKHRyYW5zWCAqIHNjYWxlIC0gdHJhbnNYU3RhcnQpIC8gY291bnQ7XG4gICAgdHJhbnNZRGlmZiA9ICh0cmFuc1kgKiBzY2FsZSAtIHRyYW5zWVN0YXJ0KSAvIGNvdW50O1xuICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaSArPSAxO1xuICAgICAgX3RoaXMuc2NhbGUgPSBzY2FsZVN0YXJ0ICsgc2NhbGVEaWZmICogaTtcbiAgICAgIF90aGlzLnRyYW5zWCA9ICh0cmFuc1hTdGFydCArIHRyYW5zWERpZmYgKiBpKSAvIF90aGlzLnNjYWxlO1xuICAgICAgX3RoaXMudHJhbnNZID0gKHRyYW5zWVN0YXJ0ICsgdHJhbnNZRGlmZiAqIGkpIC8gX3RoaXMuc2NhbGU7XG4gICAgICBfdGhpcy5fYXBwbHlUcmFuc2Zvcm0oKTtcbiAgICAgIGlmIChpID09IGNvdW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICBfdGhpcy5fZW1pdChFdmVudHMub25WaWV3cG9ydENoYW5nZSwgW190aGlzLnNjYWxlLCBfdGhpcy50cmFuc1gsIF90aGlzLnRyYW5zWV0pO1xuICAgICAgfVxuICAgIH0sIDEwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRyYW5zWCA9IHRyYW5zWDtcbiAgICB0aGlzLnRyYW5zWSA9IHRyYW5zWTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5fYXBwbHlUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl9lbWl0KEV2ZW50cy5vblZpZXdwb3J0Q2hhbmdlLCBbdGhpcy5zY2FsZSwgdGhpcy50cmFuc1gsIHRoaXMudHJhbnNZXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Rm9jdXMoY29uZmlnKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgIGNvbmZpZyA9IHt9O1xuICB9XG4gIHZhciBiYm94LFxuICAgIGNvZGVzID0gW107XG4gIGlmIChjb25maWcucmVnaW9uKSB7XG4gICAgY29kZXMucHVzaChjb25maWcucmVnaW9uKTtcbiAgfSBlbHNlIGlmIChjb25maWcucmVnaW9ucykge1xuICAgIGNvZGVzID0gY29uZmlnLnJlZ2lvbnM7XG4gIH1cbiAgaWYgKGNvZGVzLmxlbmd0aCkge1xuICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIGlmIChfdGhpcy5yZWdpb25zW2NvZGVdKSB7XG4gICAgICAgIHZhciBpdGVtQmJveCA9IF90aGlzLnJlZ2lvbnNbY29kZV0uZWxlbWVudC5zaGFwZS5nZXRCQm94KCk7XG4gICAgICAgIGlmIChpdGVtQmJveCkge1xuICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZmlyc3QgbG9vcFxuICAgICAgICAgIGlmICh0eXBlb2YgYmJveCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYmJveCA9IGl0ZW1CYm94O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIG9sZCBiYm94IHByb3BlcnRpZXMgcGx1cyB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8gdGhpcyBraW5kYSBpbmNyZW1lbnRpbmcgdGhlIG9sZCB2YWx1ZXMgYW5kIHRoZSBuZXcgdmFsdWVzXG4gICAgICAgICAgICBiYm94ID0ge1xuICAgICAgICAgICAgICB4OiBNYXRoLm1pbihiYm94LngsIGl0ZW1CYm94LngpLFxuICAgICAgICAgICAgICB5OiBNYXRoLm1pbihiYm94LnksIGl0ZW1CYm94LnkpLFxuICAgICAgICAgICAgICB3aWR0aDogTWF0aC5tYXgoYmJveC54ICsgYmJveC53aWR0aCwgaXRlbUJib3gueCArIGl0ZW1CYm94LndpZHRoKSAtIE1hdGgubWluKGJib3gueCwgaXRlbUJib3gueCksXG4gICAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoYmJveC55ICsgYmJveC5oZWlnaHQsIGl0ZW1CYm94LnkgKyBpdGVtQmJveC5oZWlnaHQpIC0gTWF0aC5taW4oYmJveC55LCBpdGVtQmJveC55KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fc2V0U2NhbGUoTWF0aC5taW4odGhpcy5fd2lkdGggLyBiYm94LndpZHRoLCB0aGlzLl9oZWlnaHQgLyBiYm94LmhlaWdodCksIC0oYmJveC54ICsgYmJveC53aWR0aCAvIDIpLCAtKGJib3gueSArIGJib3guaGVpZ2h0IC8gMiksIHRydWUsIGNvbmZpZy5hbmltYXRlKTtcbiAgfSBlbHNlIGlmIChjb25maWcuY29vcmRzKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5jb29yZHNUb1BvaW50KGNvbmZpZy5jb29yZHNbMF0sIGNvbmZpZy5jb29yZHNbMV0pO1xuICAgIHZhciB4ID0gdGhpcy50cmFuc1ggLSBwb2ludC54IC8gdGhpcy5zY2FsZTtcbiAgICB2YXIgeSA9IHRoaXMudHJhbnNZIC0gcG9pbnQueSAvIHRoaXMuc2NhbGU7XG4gICAgcmV0dXJuIHRoaXMuX3NldFNjYWxlKGNvbmZpZy5zY2FsZSAqIHRoaXMuX2Jhc2VTY2FsZSwgeCwgeSwgdHJ1ZSwgY29uZmlnLmFuaW1hdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7XG4gIHRoaXMuX3dpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgdGhpcy5fcmVzaXplKCk7XG4gIHRoaXMuY2FudmFzLnNldFNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNmb3JtKCk7XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBPYmplY3RcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG52YXIgUHJvaiA9IHtcbiAgLyogc2duKG4pe1xuICAgIGlmIChuID4gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChuIDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH0sICovXG4gIG1pbGw6IGZ1bmN0aW9uIG1pbGwobGF0LCBsbmcsIGMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5yYWRpdXMgKiAobG5nIC0gYykgKiB0aGlzLnJhZERlZyxcbiAgICAgIHk6IC10aGlzLnJhZGl1cyAqIE1hdGgubG9nKE1hdGgudGFuKCg0NSArIDAuNCAqIGxhdCkgKiB0aGlzLnJhZERlZykpIC8gMC44XG4gICAgfTtcbiAgfSxcbiAgLyogbWlsbF9pbnYoeCwgeSwgYykge1xuICAgIHJldHVybiB7XG4gICAgICBsYXQ6ICgyLjUgKiBNYXRoLmF0YW4oTWF0aC5leHAoMC44ICogeSAvIHRoaXMucmFkaXVzKSkgLSA1ICogTWF0aC5QSSAvIDgpICogdGhpcy5kZWdSYWQsXG4gICAgICBsbmc6IChjICogdGhpcy5yYWREZWcgKyB4IC8gdGhpcy5yYWRpdXMpICogdGhpcy5kZWdSYWRcbiAgICB9O1xuICB9LCAqL1xuICBtZXJjOiBmdW5jdGlvbiBtZXJjKGxhdCwgbG5nLCBjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMucmFkaXVzICogKGxuZyAtIGMpICogdGhpcy5yYWREZWcsXG4gICAgICB5OiAtdGhpcy5yYWRpdXMgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIGxhdCAqIE1hdGguUEkgLyAzNjApKVxuICAgIH07XG4gIH0sXG4gIC8qIG1lcmNfaW52KHgsIHksIGMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGF0OiAoMiAqIE1hdGguYXRhbihNYXRoLmV4cCh5IC8gdGhpcy5yYWRpdXMpKSAtIE1hdGguUEkgLyAyKSAqIHRoaXMuZGVnUmFkLFxuICAgICAgbG5nOiAoYyAqIHRoaXMucmFkRGVnICsgeCAvIHRoaXMucmFkaXVzKSAqIHRoaXMuZGVnUmFkXG4gICAgfTtcbiAgfSwgKi9cbiAgYWVhOiBmdW5jdGlvbiBhZWEobGF0LCBsbmcsIGMpIHtcbiAgICB2YXIgZmkwID0gMCxcbiAgICAgIGxhbWJkYTAgPSBjICogdGhpcy5yYWREZWcsXG4gICAgICBmaTEgPSAyOS41ICogdGhpcy5yYWREZWcsXG4gICAgICBmaTIgPSA0NS41ICogdGhpcy5yYWREZWcsXG4gICAgICBmaSA9IGxhdCAqIHRoaXMucmFkRGVnLFxuICAgICAgbGFtYmRhID0gbG5nICogdGhpcy5yYWREZWcsXG4gICAgICBuID0gKE1hdGguc2luKGZpMSkgKyBNYXRoLnNpbihmaTIpKSAvIDIsXG4gICAgICBDID0gTWF0aC5jb3MoZmkxKSAqIE1hdGguY29zKGZpMSkgKyAyICogbiAqIE1hdGguc2luKGZpMSksXG4gICAgICB0aGV0YSA9IG4gKiAobGFtYmRhIC0gbGFtYmRhMCksXG4gICAgICBybyA9IE1hdGguc3FydChDIC0gMiAqIG4gKiBNYXRoLnNpbihmaSkpIC8gbixcbiAgICAgIHJvMCA9IE1hdGguc3FydChDIC0gMiAqIG4gKiBNYXRoLnNpbihmaTApKSAvIG47XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJvICogTWF0aC5zaW4odGhldGEpICogdGhpcy5yYWRpdXMsXG4gICAgICB5OiAtKHJvMCAtIHJvICogTWF0aC5jb3ModGhldGEpKSAqIHRoaXMucmFkaXVzXG4gICAgfTtcbiAgfSxcbiAgLyogYWVhX2ludih4Q29vcmQsIHlDb29yZCwgYykge1xuICAgIHZhciB4ID0geENvb3JkIC8gdGhpcy5yYWRpdXMsXG4gICAgICAgIHkgPSB5Q29vcmQgLyB0aGlzLnJhZGl1cyxcbiAgICAgICAgZmkwID0gMCxcbiAgICAgICAgbGFtYmRhMCA9IGMgKiB0aGlzLnJhZERlZyxcbiAgICAgICAgZmkxID0gMjkuNSAqIHRoaXMucmFkRGVnLFxuICAgICAgICBmaTIgPSA0NS41ICogdGhpcy5yYWREZWcsXG4gICAgICAgIG4gPSAoTWF0aC5zaW4oZmkxKStNYXRoLnNpbihmaTIpKSAvIDIsXG4gICAgICAgIEMgPSBNYXRoLmNvcyhmaTEpKk1hdGguY29zKGZpMSkrMipuKk1hdGguc2luKGZpMSksXG4gICAgICAgIHJvMCA9IE1hdGguc3FydChDLTIqbipNYXRoLnNpbihmaTApKS9uLFxuICAgICAgICBybyA9IE1hdGguc3FydCh4KngrKHJvMC15KSoocm8wLXkpKSxcbiAgICAgICAgdGhldGEgPSBNYXRoLmF0YW4oIHggLyAocm8wIC0geSkgKTtcbiAgICAgcmV0dXJuIHtcbiAgICAgIGxhdDogKE1hdGguYXNpbigoQyAtIHJvICogcm8gKiBuICogbikgLyAoMiAqIG4pKSkgKiB0aGlzLmRlZ1JhZCxcbiAgICAgIGxuZzogKGxhbWJkYTAgKyB0aGV0YSAvIG4pICogdGhpcy5kZWdSYWRcbiAgICB9O1xuICB9LCAqL1xuICBsY2M6IGZ1bmN0aW9uIGxjYyhsYXQsIGxuZywgYykge1xuICAgIHZhciBmaTAgPSAwLFxuICAgICAgbGFtYmRhMCA9IGMgKiB0aGlzLnJhZERlZyxcbiAgICAgIGxhbWJkYSA9IGxuZyAqIHRoaXMucmFkRGVnLFxuICAgICAgZmkxID0gMzMgKiB0aGlzLnJhZERlZyxcbiAgICAgIGZpMiA9IDQ1ICogdGhpcy5yYWREZWcsXG4gICAgICBmaSA9IGxhdCAqIHRoaXMucmFkRGVnLFxuICAgICAgbiA9IE1hdGgubG9nKE1hdGguY29zKGZpMSkgKiAoMSAvIE1hdGguY29zKGZpMikpKSAvIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgZmkyIC8gMikgKiAoMSAvIE1hdGgudGFuKE1hdGguUEkgLyA0ICsgZmkxIC8gMikpKSxcbiAgICAgIEYgPSBNYXRoLmNvcyhmaTEpICogTWF0aC5wb3coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBmaTEgLyAyKSwgbikgLyBuLFxuICAgICAgcm8gPSBGICogTWF0aC5wb3coMSAvIE1hdGgudGFuKE1hdGguUEkgLyA0ICsgZmkgLyAyKSwgbiksXG4gICAgICBybzAgPSBGICogTWF0aC5wb3coMSAvIE1hdGgudGFuKE1hdGguUEkgLyA0ICsgZmkwIC8gMiksIG4pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBybyAqIE1hdGguc2luKG4gKiAobGFtYmRhIC0gbGFtYmRhMCkpICogdGhpcy5yYWRpdXMsXG4gICAgICB5OiAtKHJvMCAtIHJvICogTWF0aC5jb3MobiAqIChsYW1iZGEgLSBsYW1iZGEwKSkpICogdGhpcy5yYWRpdXNcbiAgICB9O1xuICB9XG4gIC8qIGxjY19pbnYoeENvb3JkLCB5Q29vcmQsIGMpIHtcbiAgICB2YXIgeCA9IHhDb29yZCAvIHRoaXMucmFkaXVzLFxuICAgICAgICB5ID0geUNvb3JkIC8gdGhpcy5yYWRpdXMsXG4gICAgICAgIGZpMCA9IDAsXG4gICAgICAgIGxhbWJkYTAgPSBjICogdGhpcy5yYWREZWcsXG4gICAgICAgIGZpMSA9IDMzICogdGhpcy5yYWREZWcsXG4gICAgICAgIGZpMiA9IDQ1ICogdGhpcy5yYWREZWcsXG4gICAgICAgIG4gPSBNYXRoLmxvZyggTWF0aC5jb3MoZmkxKSAqICgxIC8gTWF0aC5jb3MoZmkyKSkgKSAvIE1hdGgubG9nKCBNYXRoLnRhbiggTWF0aC5QSSAvIDQgKyBmaTIgLyAyKSAqICgxIC8gTWF0aC50YW4oIE1hdGguUEkgLyA0ICsgZmkxIC8gMikgKSApLFxuICAgICAgICBGID0gKCBNYXRoLmNvcyhmaTEpICogTWF0aC5wb3coIE1hdGgudGFuKCBNYXRoLlBJIC8gNCArIGZpMSAvIDIgKSwgbiApICkgLyBuLFxuICAgICAgICBybzAgPSBGICogTWF0aC5wb3coIDEgLyBNYXRoLnRhbiggTWF0aC5QSSAvIDQgKyBmaTAgLyAyICksIG4gKSxcbiAgICAgICAgcm8gPSB0aGlzLnNnbihuKSAqIE1hdGguc3FydCh4KngrKHJvMC15KSoocm8wLXkpKSxcbiAgICAgICAgdGhldGEgPSBNYXRoLmF0YW4oIHggLyAocm8wIC0geSkgKTtcbiAgICAgcmV0dXJuIHtcbiAgICAgIGxhdDogKDIgKiBNYXRoLmF0YW4oTWF0aC5wb3coRi9ybywgMS9uKSkgLSBNYXRoLlBJIC8gMikgKiB0aGlzLmRlZ1JhZCxcbiAgICAgIGxuZzogKGxhbWJkYTAgKyB0aGV0YSAvIG4pICogdGhpcy5kZWdSYWRcbiAgICB9O1xuICB9ICovXG59O1xuUHJvai5kZWdSYWQgPSAxODAgLyBNYXRoLlBJO1xuUHJvai5yYWREZWcgPSBNYXRoLlBJIC8gMTgwO1xuUHJvai5yYWRpdXMgPSA2MzgxMzcyO1xuXG5mdW5jdGlvbiBjb29yZHNUb1BvaW50KGxhdCwgbG5nKSB7XG4gIHZhciBwcm9qZWN0aW9uID0gTWFwLm1hcHNbdGhpcy5wYXJhbXMubWFwXS5wcm9qZWN0aW9uO1xuICB2YXIgX1Byb2okcHJvamVjdGlvbiR0eXBlID0gUHJvaltwcm9qZWN0aW9uLnR5cGVdKGxhdCwgbG5nLCBwcm9qZWN0aW9uLmNlbnRyYWxNZXJpZGlhbiksXG4gICAgeCA9IF9Qcm9qJHByb2plY3Rpb24kdHlwZS54LFxuICAgIHkgPSBfUHJvaiRwcm9qZWN0aW9uJHR5cGUueTtcbiAgdmFyIGluc2V0ID0gdGhpcy5nZXRJbnNldEZvclBvaW50KHgsIHkpO1xuICBpZiAoIWluc2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBiYm94ID0gaW5zZXQuYmJveDtcbiAgeCA9ICh4IC0gYmJveFswXS54KSAvIChiYm94WzFdLnggLSBiYm94WzBdLngpICogaW5zZXQud2lkdGggKiB0aGlzLnNjYWxlO1xuICB5ID0gKHkgLSBiYm94WzBdLnkpIC8gKGJib3hbMV0ueSAtIGJib3hbMF0ueSkgKiBpbnNldC5oZWlnaHQgKiB0aGlzLnNjYWxlO1xuICByZXR1cm4ge1xuICAgIHg6IHggKyB0aGlzLnRyYW5zWCAqIHRoaXMuc2NhbGUgKyBpbnNldC5sZWZ0ICogdGhpcy5zY2FsZSxcbiAgICB5OiB5ICsgdGhpcy50cmFuc1kgKiB0aGlzLnNjYWxlICsgaW5zZXQudG9wICogdGhpcy5zY2FsZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRJbnNldEZvclBvaW50KHgsIHkpIHtcbiAgdmFyIGluc2V0cyA9IE1hcC5tYXBzW3RoaXMucGFyYW1zLm1hcF0uaW5zZXRzO1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaW5zZXRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHZhciBfaW5zZXRzJGluZGV4JGJib3ggPSBpbnNldHNbaW5kZXhdLmJib3gsXG4gICAgICBzdGFydCA9IF9pbnNldHMkaW5kZXgkYmJveFswXSxcbiAgICAgIGVuZCA9IF9pbnNldHMkaW5kZXgkYmJveFsxXTtcbiAgICBpZiAoeCA+IHN0YXJ0LnggJiYgeCA8IGVuZC54ICYmIHkgPiBzdGFydC55ICYmIHkgPCBlbmQueSkge1xuICAgICAgcmV0dXJuIGluc2V0c1tpbmRleF07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1hcmtlclBvc2l0aW9uKF9yZWYpIHtcbiAgdmFyIGNvb3JkcyA9IF9yZWYuY29vcmRzO1xuICBpZiAoTWFwLm1hcHNbdGhpcy5wYXJhbXMubWFwXS5wcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuY29vcmRzVG9Qb2ludC5hcHBseSh0aGlzLCBjb29yZHMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogY29vcmRzWzBdICogdGhpcy5zY2FsZSArIHRoaXMudHJhbnNYICogdGhpcy5zY2FsZSxcbiAgICB5OiBjb29yZHNbMV0gKiB0aGlzLnNjYWxlICsgdGhpcy50cmFuc1kgKiB0aGlzLnNjYWxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcG9zaXRpb25MaW5lcygpIHtcbiAgdmFyIHBvaW50MSA9IGZhbHNlLFxuICAgIHBvaW50MiA9IGZhbHNlO1xuICBmb3IgKHZhciBpbmRleCBpbiB0aGlzLl9saW5lcykge1xuICAgIGZvciAodmFyIG1pbmRleCBpbiB0aGlzLl9tYXJrZXJzKSB7XG4gICAgICB2YXIgbWFya2VyID0gdGhpcy5fbWFya2Vyc1ttaW5kZXhdO1xuICAgICAgaWYgKG1hcmtlci5jb25maWcubmFtZSA9PT0gdGhpcy5fbGluZXNbaW5kZXhdLmNvbmZpZy5mcm9tKSB7XG4gICAgICAgIHBvaW50MSA9IHRoaXMuZ2V0TWFya2VyUG9zaXRpb24obWFya2VyLmNvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAobWFya2VyLmNvbmZpZy5uYW1lID09PSB0aGlzLl9saW5lc1tpbmRleF0uY29uZmlnLnRvKSB7XG4gICAgICAgIHBvaW50MiA9IHRoaXMuZ2V0TWFya2VyUG9zaXRpb24obWFya2VyLmNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwb2ludDEgIT09IGZhbHNlICYmIHBvaW50MiAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX2xpbmVzW2luZGV4XS5zZXRTdHlsZSh7XG4gICAgICAgIHgxOiBwb2ludDEueCxcbiAgICAgICAgeTE6IHBvaW50MS55LFxuICAgICAgICB4MjogcG9pbnQyLngsXG4gICAgICAgIHkyOiBwb2ludDIueVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcG9zaXRpb25NYXJrZXJzKCkge1xuICBmb3IgKHZhciBpbmRleCBpbiB0aGlzLl9tYXJrZXJzKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5nZXRNYXJrZXJQb3NpdGlvbih0aGlzLl9tYXJrZXJzW2luZGV4XS5jb25maWcpO1xuICAgIGlmIChwb2ludCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX21hcmtlcnNbaW5kZXhdLmVsZW1lbnQuc2V0U3R5bGUoe1xuICAgICAgICBjeDogcG9pbnQueCxcbiAgICAgICAgY3k6IHBvaW50LnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBvc2l0aW9uTGFiZWxzKCkge1xuICB2YXIgbGFiZWxzID0gdGhpcy5wYXJhbXMubGFiZWxzO1xuICBpZiAoIWxhYmVscykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlZ2lvbnMgbGFiZWxzXG4gIGlmIChsYWJlbHMucmVnaW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnJlZ2lvbnMpIHtcbiAgICAgIHRoaXMucmVnaW9uc1trZXldLmVsZW1lbnQudXBkYXRlTGFiZWxQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1hcmtlcnMgbGFiZWxzXG4gIGlmIChsYWJlbHMubWFya2Vycykge1xuICAgIGZvciAodmFyIF9rZXkgaW4gdGhpcy5fbWFya2Vycykge1xuICAgICAgdGhpcy5fbWFya2Vyc1tfa2V5XS5lbGVtZW50LnVwZGF0ZUxhYmVsUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGNvcmUgPSB7XG4gIF9zZXR1cENvbnRhaW5lckV2ZW50czogc2V0dXBDb250YWluZXJFdmVudHMsXG4gIF9zZXR1cEVsZW1lbnRFdmVudHM6IHNldHVwRWxlbWVudEV2ZW50cyxcbiAgX3NldHVwWm9vbUJ1dHRvbnM6IHNldHVwWm9vbUJ1dHRvbnMsXG4gIF9zZXR1cENvbnRhaW5lclRvdWNoRXZlbnRzOiBzZXR1cENvbnRhaW5lclRvdWNoRXZlbnRzLFxuICBfY3JlYXRlUmVnaW9uczogY3JlYXRlUmVnaW9ucyxcbiAgX2NyZWF0ZUxpbmVzOiBjcmVhdGVMaW5lcyxcbiAgX2NyZWF0ZU1hcmtlcnM6IGNyZWF0ZU1hcmtlcnMsXG4gIF9jcmVhdGVTZXJpZXM6IGNyZWF0ZVNlcmllcyxcbiAgX2FwcGx5VHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcbiAgX3Jlc2l6ZTogcmVzaXplLFxuICBfc2V0U2NhbGU6IHNldFNjYWxlLFxuICBzZXRGb2N1czogc2V0Rm9jdXMsXG4gIHVwZGF0ZVNpemU6IHVwZGF0ZVNpemUsXG4gIGNvb3Jkc1RvUG9pbnQ6IGNvb3Jkc1RvUG9pbnQsXG4gIGdldEluc2V0Rm9yUG9pbnQ6IGdldEluc2V0Rm9yUG9pbnQsXG4gIGdldE1hcmtlclBvc2l0aW9uOiBnZXRNYXJrZXJQb3NpdGlvbixcbiAgX3JlcG9zaXRpb25MaW5lczogcmVwb3NpdGlvbkxpbmVzLFxuICBfcmVwb3NpdGlvbk1hcmtlcnM6IHJlcG9zaXRpb25NYXJrZXJzLFxuICBfcmVwb3NpdGlvbkxhYmVsczogcmVwb3NpdGlvbkxhYmVsc1xufTtcblxudmFyIERlZmF1bHRzID0ge1xuICBtYXA6ICd3b3JsZCcsXG4gIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgZHJhZ2dhYmxlOiB0cnVlLFxuICB6b29tQnV0dG9uczogdHJ1ZSxcbiAgem9vbU9uU2Nyb2xsOiB0cnVlLFxuICB6b29tT25TY3JvbGxTcGVlZDogMyxcbiAgem9vbU1heDogMTIsXG4gIHpvb21NaW46IDEsXG4gIHpvb21BbmltYXRlOiB0cnVlLFxuICBzaG93VG9vbHRpcDogdHJ1ZSxcbiAgem9vbVN0ZXA6IDEuNSxcbiAgYmluZFRvdWNoRXZlbnRzOiB0cnVlLFxuICAvLyBMaW5lIG9wdGlvbnNcbiAgbGluZVN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzgwODA4MCcsXG4gICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJ1xuICB9LFxuICAvLyBNYXJrZXIgb3B0aW9uc1xuICBtYXJrZXJzU2VsZWN0YWJsZTogZmFsc2UsXG4gIG1hcmtlcnNTZWxlY3RhYmxlT25lOiBmYWxzZSxcbiAgbWFya2VyU3R5bGU6IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICByOiA3LFxuICAgICAgZmlsbDogJyMzNzQxNTEnLFxuICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICBzdHJva2U6ICcjRkZGJyxcbiAgICAgIHN0cm9rZVdpZHRoOiA1LFxuICAgICAgc3Ryb2tlT3BhY2l0eTogLjVcbiAgICB9LFxuICAgIGhvdmVyOiB7XG4gICAgICBmaWxsOiAnIzNjYzBmZicsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgIH0sXG4gICAgc2VsZWN0ZWQ6IHtcbiAgICAgIGZpbGw6ICdibHVlJ1xuICAgIH0sXG4gICAgc2VsZWN0ZWRIb3Zlcjoge31cbiAgfSxcbiAgbWFya2VyTGFiZWxTdHlsZToge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGZvbnRGYW1pbHk6ICdWZXJkYW5hJyxcbiAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgIGZvbnRXZWlnaHQ6IDUwMCxcbiAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgZmlsbDogJyMzNzQxNTEnXG4gICAgfSxcbiAgICBob3Zlcjoge1xuICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICB9LFxuICAgIHNlbGVjdGVkOiB7fSxcbiAgICBzZWxlY3RlZEhvdmVyOiB7fVxuICB9LFxuICAvLyBSZWdpb24gb3B0aW9uc1xuICByZWdpb25zU2VsZWN0YWJsZTogZmFsc2UsXG4gIHJlZ2lvbnNTZWxlY3RhYmxlT25lOiBmYWxzZSxcbiAgcmVnaW9uU3R5bGU6IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICBmaWxsOiAnI2RlZTJlOCcsXG4gICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgIHN0cm9rZTogJ25vbmUnLFxuICAgICAgc3Ryb2tlV2lkdGg6IDBcbiAgICB9LFxuICAgIGhvdmVyOiB7XG4gICAgICBmaWxsT3BhY2l0eTogLjcsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgIH0sXG4gICAgc2VsZWN0ZWQ6IHtcbiAgICAgIGZpbGw6ICcjOWNhM2FmJ1xuICAgIH0sXG4gICAgc2VsZWN0ZWRIb3Zlcjoge31cbiAgfSxcbiAgcmVnaW9uTGFiZWxTdHlsZToge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGZvbnRGYW1pbHk6ICdWZXJkYW5hJyxcbiAgICAgIGZvbnRTaXplOiAnMTInLFxuICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgICBmaWxsOiAnIzM1MzczZSdcbiAgICB9LFxuICAgIGhvdmVyOiB7XG4gICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG52YXIgU1ZHRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNWR0VsZW1lbnQobmFtZSwgY29uZmlnKSB7XG4gICAgdGhpcy5ub2RlID0gdGhpcy5fY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICB0aGlzLnNldChjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBuZXcgU1ZHIGVsZW1lbnQgYHN2Z2AsIGBnYCwgYHBhdGhgLCBgbGluZWAsIGBjaXJjbGVgLCBgaW1hZ2VgLCBldGMuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9jcmVhdGVFbGVtZW50TlMjaW1wb3J0YW50X25hbWVzcGFjZV91cmlzXG4gIHZhciBfcHJvdG8gPSBTVkdFbGVtZW50LnByb3RvdHlwZTtcbiAgX3Byb3RvLl9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodGFnTmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdGFnTmFtZSk7XG4gIH07XG4gIF9wcm90by5hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKGNsYXNzTmFtZSkge1xuICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lKTtcbiAgfTtcbiAgX3Byb3RvLmdldEJCb3ggPSBmdW5jdGlvbiBnZXRCQm94KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0QkJveCgpO1xuICB9XG5cbiAgLy8gQXBwbHkgYXR0cmlidXRlcyBvbiB0aGUgY3VycmVudCBub2RlIGVsZW1lbnRcbiAgO1xuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBhdHRyIGluIHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMuYXBwbHlBdHRyKGF0dHIsIHByb3BlcnR5W2F0dHJdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBseUF0dHIocHJvcGVydHksIHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQocHJvcGVydHkpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZS5pbml0aWFsW3Byb3BlcnR5XTtcbiAgfTtcbiAgX3Byb3RvLmFwcGx5QXR0ciA9IGZ1bmN0aW9uIGFwcGx5QXR0cihwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShwcm9wZXJ0eSksIHZhbHVlKTtcbiAgfTtcbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICByZW1vdmVFbGVtZW50KHRoaXMubm9kZSk7XG4gIH07XG4gIHJldHVybiBTVkdFbGVtZW50O1xufSgpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbnZhciBTVkdTaGFwZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TVkdFbGVtZW50KSB7XG4gIGZ1bmN0aW9uIFNWR1NoYXBlRWxlbWVudChuYW1lLCBjb25maWcsIHN0eWxlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGlmIChzdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdHlsZSA9IHt9O1xuICAgIH1cbiAgICBfdGhpcyA9IF9TVkdFbGVtZW50LmNhbGwodGhpcywgbmFtZSwgY29uZmlnKSB8fCB0aGlzO1xuICAgIF90aGlzLmlzSG92ZXJlZCA9IGZhbHNlO1xuICAgIF90aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIF90aGlzLnN0eWxlLmN1cnJlbnQgPSB7fTtcbiAgICBfdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHNMb29zZShTVkdTaGFwZUVsZW1lbnQsIF9TVkdFbGVtZW50KTtcbiAgdmFyIF9wcm90byA9IFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGU7XG4gIF9wcm90by5zZXRTdHlsZSA9IGZ1bmN0aW9uIHNldFN0eWxlKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdvYmplY3QnKSB7XG4gICAgICBtZXJnZSh0aGlzLnN0eWxlLmN1cnJlbnQsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9tZXJnZTtcbiAgICAgIG1lcmdlKHRoaXMuc3R5bGUuY3VycmVudCwgKF9tZXJnZSA9IHt9LCBfbWVyZ2VbcHJvcGVydHldID0gdmFsdWUsIF9tZXJnZSkpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gIH07XG4gIF9wcm90by51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKCkge1xuICAgIHZhciBhdHRycyA9IHt9O1xuICAgIG1lcmdlKGF0dHJzLCB0aGlzLnN0eWxlLmluaXRpYWwpO1xuICAgIG1lcmdlKGF0dHJzLCB0aGlzLnN0eWxlLmN1cnJlbnQpO1xuICAgIGlmICh0aGlzLmlzSG92ZXJlZCkge1xuICAgICAgbWVyZ2UoYXR0cnMsIHRoaXMuc3R5bGUuaG92ZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICBtZXJnZShhdHRycywgdGhpcy5zdHlsZS5zZWxlY3RlZCk7XG4gICAgICBpZiAodGhpcy5pc0hvdmVyZWQpIHtcbiAgICAgICAgbWVyZ2UoYXR0cnMsIHRoaXMuc3R5bGUuc2VsZWN0ZWRIb3Zlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0KGF0dHJzKTtcbiAgfTtcbiAgcmV0dXJuIFNWR1NoYXBlRWxlbWVudDtcbn0oU1ZHRWxlbWVudCk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xudmFyIFNWR1RleHRFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU1ZHU2hhcGVFbGVtZW50KSB7XG4gIGZ1bmN0aW9uIFNWR1RleHRFbGVtZW50KGNvbmZpZywgc3R5bGUpIHtcbiAgICByZXR1cm4gX1NWR1NoYXBlRWxlbWVudC5jYWxsKHRoaXMsICd0ZXh0JywgY29uZmlnLCBzdHlsZSkgfHwgdGhpcztcbiAgfVxuICBfaW5oZXJpdHNMb29zZShTVkdUZXh0RWxlbWVudCwgX1NWR1NoYXBlRWxlbWVudCk7XG4gIHZhciBfcHJvdG8gPSBTVkdUZXh0RWxlbWVudC5wcm90b3R5cGU7XG4gIF9wcm90by5hcHBseUF0dHIgPSBmdW5jdGlvbiBhcHBseUF0dHIoYXR0ciwgdmFsdWUpIHtcbiAgICBhdHRyID09PSAndGV4dCcgPyB0aGlzLm5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZSA6IF9TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmFwcGx5QXR0ci5jYWxsKHRoaXMsIGF0dHIsIHZhbHVlKTtcbiAgfTtcbiAgcmV0dXJuIFNWR1RleHRFbGVtZW50O1xufShTVkdTaGFwZUVsZW1lbnQpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbnZhciBTVkdJbWFnZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TVkdTaGFwZUVsZW1lbnQpIHtcbiAgZnVuY3Rpb24gU1ZHSW1hZ2VFbGVtZW50KGNvbmZpZywgc3R5bGUpIHtcbiAgICByZXR1cm4gX1NWR1NoYXBlRWxlbWVudC5jYWxsKHRoaXMsICdpbWFnZScsIGNvbmZpZywgc3R5bGUpIHx8IHRoaXM7XG4gIH1cbiAgX2luaGVyaXRzTG9vc2UoU1ZHSW1hZ2VFbGVtZW50LCBfU1ZHU2hhcGVFbGVtZW50KTtcbiAgdmFyIF9wcm90byA9IFNWR0ltYWdlRWxlbWVudC5wcm90b3R5cGU7XG4gIF9wcm90by5hcHBseUF0dHIgPSBmdW5jdGlvbiBhcHBseUF0dHIoYXR0ciwgdmFsdWUpIHtcbiAgICB2YXIgaW1hZ2VVcmw7XG4gICAgaWYgKGF0dHIgPT09ICdpbWFnZScpIHtcbiAgICAgIC8vIFRoaXMgZ2V0IGV4ZWN1dGVkIHdoZW4gd2UgaGF2ZSB1cmwgaW4gc2VyaWVzLm1hcmtlcnNbMF0uc2NhbGUuc29tZVNjYWxlLnVybFxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaW1hZ2VVcmwgPSB2YWx1ZS51cmw7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gdmFsdWUub2Zmc2V0IHx8IFswLCAwXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlVXJsID0gdmFsdWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gWzAsIDBdO1xuICAgICAgfVxuICAgICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCBpbWFnZVVybCk7XG5cbiAgICAgIC8vIFNldCB3aWR0aCBhbmQgaGVpZ2h0IHRoZW4gY2FsbCB0aGlzIGBhcHBseUF0dHJgIGFnYWluXG4gICAgICB0aGlzLndpZHRoID0gMjM7XG4gICAgICB0aGlzLmhlaWdodCA9IDIzO1xuICAgICAgdGhpcy5hcHBseUF0dHIoJ3dpZHRoJywgdGhpcy53aWR0aCk7XG4gICAgICB0aGlzLmFwcGx5QXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5hcHBseUF0dHIoJ3gnLCB0aGlzLmN4IC0gdGhpcy53aWR0aCAvIDIgKyB0aGlzLm9mZnNldFswXSk7XG4gICAgICB0aGlzLmFwcGx5QXR0cigneScsIHRoaXMuY3kgLSB0aGlzLmhlaWdodCAvIDIgKyB0aGlzLm9mZnNldFsxXSk7XG4gICAgfSBlbHNlIGlmIChhdHRyID09ICdjeCcpIHtcbiAgICAgIHRoaXMuY3ggPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICAgIHRoaXMuYXBwbHlBdHRyKCd4JywgdmFsdWUgLSB0aGlzLndpZHRoIC8gMiArIHRoaXMub2Zmc2V0WzBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHIgPT0gJ2N5Jykge1xuICAgICAgdGhpcy5jeSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuYXBwbHlBdHRyKCd5JywgdmFsdWUgLSB0aGlzLmhlaWdodCAvIDIgKyB0aGlzLm9mZnNldFsxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgdGltZSBDYWxsIFNWR0VsZW1lbnRcbiAgICAgIF9TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmFwcGx5QXR0ci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFNWR0ltYWdlRWxlbWVudDtcbn0oU1ZHU2hhcGVFbGVtZW50KTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG52YXIgU1ZHQ2FudmFzRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NWR0VsZW1lbnQpIHtcbiAgZnVuY3Rpb24gU1ZHQ2FudmFzRWxlbWVudChjb250YWluZXIpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfU1ZHRWxlbWVudC5jYWxsKHRoaXMsICdzdmcnKSB8fCB0aGlzOyAvLyBDcmVhdGUgc3ZnIGVsZW1lbnQgZm9yIGhvbGRpbmcgdGhlIHdob2xlIG1hcFxuXG4gICAgX3RoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIC8vIENyZWF0ZSB0aGUgZGVmcyBlbGVtZW50XG4gICAgX3RoaXMuX2RlZnNFbGVtZW50ID0gbmV3IFNWR0VsZW1lbnQoJ2RlZnMnKTtcblxuICAgIC8vIENyZWF0ZSBncm91cCBlbGVtZW50IHdoaWNoIHdpbGwgaG9sZCB0aGUgcGF0aHMgKHJlZ2lvbnMpXG4gICAgX3RoaXMuX3Jvb3RFbGVtZW50ID0gbmV3IFNWR0VsZW1lbnQoJ2cnLCB7XG4gICAgICBpZDogJ2p2bS1yZWdpb25zLWdyb3VwJ1xuICAgIH0pO1xuXG4gICAgLy8gQXBwZW5kIHRoZSBkZWZzIGVsZW1lbnQgdG8gdGhlIHRoaXMubm9kZSAoU1ZHIHRhZylcbiAgICBfdGhpcy5ub2RlLmFwcGVuZENoaWxkKF90aGlzLl9kZWZzRWxlbWVudC5ub2RlKTtcblxuICAgIC8vIEFwcGVuZCB0aGUgZ3JvdXAgdG8gdGhpcy5ub2RlIChTVkcgdGFnKVxuICAgIF90aGlzLm5vZGUuYXBwZW5kQ2hpbGQoX3RoaXMuX3Jvb3RFbGVtZW50Lm5vZGUpO1xuXG4gICAgLy8gQXBwZW5kIHRoaXMubm9kZSAoU1ZHIHRhZykgdG8gdGhlIGNvbnRhaW5lclxuICAgIF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoX3RoaXMubm9kZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0c0xvb3NlKFNWR0NhbnZhc0VsZW1lbnQsIF9TVkdFbGVtZW50KTtcbiAgdmFyIF9wcm90byA9IFNWR0NhbnZhc0VsZW1lbnQucHJvdG90eXBlO1xuICBfcHJvdG8uc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gIH07XG4gIF9wcm90by5hcHBseVRyYW5zZm9ybVBhcmFtcyA9IGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtUGFyYW1zKHNjYWxlLCB0cmFuc1gsIHRyYW5zWSkge1xuICAgIHRoaXMuX3Jvb3RFbGVtZW50Lm5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInNjYWxlKFwiICsgc2NhbGUgKyBcIikgdHJhbnNsYXRlKFwiICsgdHJhbnNYICsgXCIsIFwiICsgdHJhbnNZICsgXCIpXCIpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGBwYXRoYCBlbGVtZW50XG4gIDtcbiAgX3Byb3RvLmNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGNvbmZpZywgc3R5bGUpIHtcbiAgICB2YXIgcGF0aCA9IG5ldyBTVkdTaGFwZUVsZW1lbnQoJ3BhdGgnLCBjb25maWcsIHN0eWxlKTtcbiAgICBwYXRoLm5vZGUuc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCAnZXZlbm9kZCcpO1xuICAgIHJldHVybiB0aGlzLl9hZGQocGF0aCk7XG4gIH1cblxuICAvLyBDcmVhdGUgYGNpcmNsZWAgZWxlbWVudFxuICA7XG4gIF9wcm90by5jcmVhdGVDaXJjbGUgPSBmdW5jdGlvbiBjcmVhdGVDaXJjbGUoY29uZmlnLCBzdHlsZSwgZ3JvdXApIHtcbiAgICB2YXIgY2lyY2xlID0gbmV3IFNWR1NoYXBlRWxlbWVudCgnY2lyY2xlJywgY29uZmlnLCBzdHlsZSk7XG4gICAgcmV0dXJuIHRoaXMuX2FkZChjaXJjbGUsIGdyb3VwKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBgbGluZWAgZWxlbWVudFxuICA7XG4gIF9wcm90by5jcmVhdGVMaW5lID0gZnVuY3Rpb24gY3JlYXRlTGluZShjb25maWcsIHN0eWxlLCBncm91cCkge1xuICAgIHZhciBsaW5lID0gbmV3IFNWR1NoYXBlRWxlbWVudCgnbGluZScsIGNvbmZpZywgc3R5bGUpO1xuICAgIHJldHVybiB0aGlzLl9hZGQobGluZSwgZ3JvdXApO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGB0ZXh0YCBlbGVtZW50XG4gIDtcbiAgX3Byb3RvLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiBjcmVhdGVUZXh0KGNvbmZpZywgc3R5bGUsIGdyb3VwKSB7XG4gICAgdmFyIHRleHQgPSBuZXcgU1ZHVGV4dEVsZW1lbnQoY29uZmlnLCBzdHlsZSk7XG4gICAgcmV0dXJuIHRoaXMuX2FkZCh0ZXh0LCBncm91cCk7XG4gIH1cblxuICAvLyBDcmVhdGUgYGltYWdlYCBlbGVtZW50XG4gIDtcbiAgX3Byb3RvLmNyZWF0ZUltYWdlID0gZnVuY3Rpb24gY3JlYXRlSW1hZ2UoY29uZmlnLCBzdHlsZSwgZ3JvdXApIHtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgU1ZHSW1hZ2VFbGVtZW50KGNvbmZpZywgc3R5bGUpO1xuICAgIHJldHVybiB0aGlzLl9hZGQoaW1hZ2UsIGdyb3VwKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBgZ2AgZWxlbWVudFxuICA7XG4gIF9wcm90by5jcmVhdGVHcm91cCA9IGZ1bmN0aW9uIGNyZWF0ZUdyb3VwKGlkKSB7XG4gICAgdmFyIGdyb3VwID0gbmV3IFNWR0VsZW1lbnQoJ2cnKTtcbiAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZ3JvdXAubm9kZSk7XG4gICAgaWYgKGlkKSB7XG4gICAgICBncm91cC5ub2RlLmlkID0gaWQ7XG4gICAgfVxuICAgIGdyb3VwLmNhbnZhcyA9IHRoaXM7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG5cbiAgLy8gQWRkIHNvbWUgZWxlbWVudCB0byBhIHNwY2lmaWMgZ3JvdXAgb3IgdGhlIHJvb3QgZWxlbWVudCBpZiB0aGUgZ3JvdXAgaXNuJ3QgZ2l2ZW5cbiAgO1xuICBfcHJvdG8uX2FkZCA9IGZ1bmN0aW9uIF9hZGQoZWxlbWVudCwgZ3JvdXApIHtcbiAgICBncm91cCA9IGdyb3VwIHx8IHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIGdyb3VwLm5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudC5ub2RlKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcbiAgcmV0dXJuIFNWR0NhbnZhc0VsZW1lbnQ7XG59KFNWR0VsZW1lbnQpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbnZhciBUb29sdGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBUb29sdGlwKG1hcCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfdGhpcyA9IF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICB2YXIgdG9vbHRpcCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsICdqdm0tdG9vbHRpcCcpO1xuICAgIF90aGlzLl9tYXAgPSBtYXA7XG4gICAgX3RoaXMuX3Rvb2x0aXAgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvb2x0aXApO1xuICAgIF90aGlzLl9iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gX3RoaXMgfHwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gIH1cbiAgX2luaGVyaXRzTG9vc2UoVG9vbHRpcCwgX0Jhc2VDb21wb25lbnQpO1xuICB2YXIgX3Byb3RvID0gVG9vbHRpcC5wcm90b3R5cGU7XG4gIF9wcm90by5fYmluZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2JpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fbWFwLmNvbnRhaW5lciwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfdGhpczIuX3Rvb2x0aXAuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY29udGFpbmVyID0gZmluZEVsZW1lbnQoX3RoaXMyLl9tYXAuY29udGFpbmVyLCAnI2p2bS1yZWdpb25zLWdyb3VwJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc3BhY2UgPSA1OyAvLyBTcGFjZSBiZXR3ZWVuIHRoZSBjdXJzb3IgYW5kIHRvb2x0aXAgZWxlbWVudFxuXG4gICAgICAvLyBUb29sdGlwXG4gICAgICB2YXIgX3RoaXMyJF90b29sdGlwJGdldEJvID0gX3RoaXMyLl90b29sdGlwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBoZWlnaHQgPSBfdGhpczIkX3Rvb2x0aXAkZ2V0Qm8uaGVpZ2h0LFxuICAgICAgICB3aWR0aCA9IF90aGlzMiRfdG9vbHRpcCRnZXRCby53aWR0aDtcbiAgICAgIHZhciB0b3BJc1Bhc3NlZCA9IGV2ZW50LmNsaWVudFkgPD0gY29udGFpbmVyLnRvcCArIGhlaWdodCArIHNwYWNlO1xuICAgICAgdmFyIHRvcCA9IGV2ZW50LnBhZ2VZIC0gaGVpZ2h0IC0gc3BhY2U7XG4gICAgICB2YXIgbGVmdCA9IGV2ZW50LnBhZ2VYIC0gd2lkdGggLSBzcGFjZTtcblxuICAgICAgLy8gRW5zdXJlIHRoZSB0b29sdGlwIHdpbGwgbmV2ZXIgY3Jvc3Mgb3V0c2lkZSB0aGUgY2FudmFzIGFyZWEobWFwKVxuICAgICAgaWYgKHRvcElzUGFzc2VkKSB7XG4gICAgICAgIC8vIFRvcDpcbiAgICAgICAgdG9wICs9IGhlaWdodCArIHNwYWNlO1xuXG4gICAgICAgIC8vIFRoZSBjdXJzb3IgaXMgYSBiaXQgbGFyZ2VyIGZyb20gbGVmdCBzaWRlXG4gICAgICAgIGxlZnQgLT0gc3BhY2UgKiAyO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmNsaWVudFggPCBjb250YWluZXIubGVmdCArIHdpZHRoICsgc3BhY2UpIHtcbiAgICAgICAgLy8gTGVmdDpcbiAgICAgICAgbGVmdCA9IGV2ZW50LnBhZ2VYICsgc3BhY2UgKyAyO1xuICAgICAgICBpZiAodG9wSXNQYXNzZWQpIHtcbiAgICAgICAgICBsZWZ0ICs9IHNwYWNlICogMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3RoaXMyLmNzcyh7XG4gICAgICAgIHRvcDogdG9wICsgXCJweFwiLFxuICAgICAgICBsZWZ0OiBsZWZ0ICsgXCJweFwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLmdldEVsZW1lbnQgPSBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl90b29sdGlwO1xuICB9O1xuICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5fdG9vbHRpcC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgfTtcbiAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuX3Rvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gIH07XG4gIF9wcm90by50ZXh0ID0gZnVuY3Rpb24gdGV4dChzdHJpbmcsIGh0bWwpIHtcbiAgICBpZiAoaHRtbCA9PT0gdm9pZCAwKSB7XG4gICAgICBodG1sID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwcm9wZXJ0eSA9IGh0bWwgPyAnaW5uZXJIVE1MJyA6ICd0ZXh0Q29udGVudCc7XG4gICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b29sdGlwW3Byb3BlcnR5XTtcbiAgICB9XG4gICAgdGhpcy5fdG9vbHRpcFtwcm9wZXJ0eV0gPSBzdHJpbmc7XG4gIH07XG4gIF9wcm90by5jc3MgPSBmdW5jdGlvbiBjc3MoX2Nzcykge1xuICAgIGZvciAodmFyIHN0eWxlIGluIF9jc3MpIHtcbiAgICAgIHRoaXMuX3Rvb2x0aXAuc3R5bGVbc3R5bGVdID0gX2Nzc1tzdHlsZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICByZXR1cm4gVG9vbHRpcDtcbn0oQmFzZUNvbXBvbmVudCk7XG5cbnZhciBEYXRhVmlzdWFsaXphdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFWaXN1YWxpemF0aW9uKF9yZWYsIG1hcCkge1xuICAgIHZhciBzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICB2YWx1ZXMgPSBfcmVmLnZhbHVlcztcbiAgICB0aGlzLl9zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICB0aGlzLl9mcm9tQ29sb3IgPSB0aGlzLmhleFRvUmdiKHNjYWxlWzBdKTtcbiAgICB0aGlzLl90b0NvbG9yID0gdGhpcy5oZXhUb1JnYihzY2FsZVsxXSk7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuc2V0TWluTWF4VmFsdWVzKHZhbHVlcyk7XG4gICAgdGhpcy52aXN1YWxpemUoKTtcbiAgfVxuICB2YXIgX3Byb3RvID0gRGF0YVZpc3VhbGl6YXRpb24ucHJvdG90eXBlO1xuICBfcHJvdG8uc2V0TWluTWF4VmFsdWVzID0gZnVuY3Rpb24gc2V0TWluTWF4VmFsdWVzKHZhbHVlcykge1xuICAgIHRoaXMubWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0aGlzLm1heCA9IDA7XG4gICAgZm9yICh2YXIgdmFsdWUgaW4gdmFsdWVzKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWVzW3ZhbHVlXSk7XG4gICAgICBpZiAodmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgICB0aGlzLm1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIDwgdGhpcy5taW4pIHtcbiAgICAgICAgdGhpcy5taW4gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by52aXN1YWxpemUgPSBmdW5jdGlvbiB2aXN1YWxpemUoKSB7XG4gICAgdmFyIGF0dHJzID0ge30sXG4gICAgICB2YWx1ZTtcbiAgICBmb3IgKHZhciByZWdpb25Db2RlIGluIHRoaXMuX3ZhbHVlcykge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuX3ZhbHVlc1tyZWdpb25Db2RlXSk7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICBhdHRyc1tyZWdpb25Db2RlXSA9IHRoaXMuZ2V0VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICB9O1xuICBfcHJvdG8uc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgICBmb3IgKHZhciBjb2RlIGluIGF0dHJzKSB7XG4gICAgICBpZiAodGhpcy5fbWFwLnJlZ2lvbnNbY29kZV0pIHtcbiAgICAgICAgdGhpcy5fbWFwLnJlZ2lvbnNbY29kZV0uZWxlbWVudC5zZXRTdHlsZSgnZmlsbCcsIGF0dHJzW2NvZGVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMubWluID09PSB0aGlzLm1heCkge1xuICAgICAgcmV0dXJuIFwiI1wiICsgdGhpcy5fdG9Db2xvci5qb2luKCcnKTtcbiAgICB9XG4gICAgdmFyIGhleCxcbiAgICAgIGNvbG9yID0gJyMnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBoZXggPSBNYXRoLnJvdW5kKHRoaXMuX2Zyb21Db2xvcltpXSArICh0aGlzLl90b0NvbG9yW2ldIC0gdGhpcy5fZnJvbUNvbG9yW2ldKSAqICgodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpKS50b1N0cmluZygxNik7XG4gICAgICBjb2xvciArPSAoaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyA6ICcnKSArIGhleDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9O1xuICBfcHJvdG8uaGV4VG9SZ2IgPSBmdW5jdGlvbiBoZXhUb1JnYihoKSB7XG4gICAgdmFyIHIgPSAwLFxuICAgICAgZyA9IDAsXG4gICAgICBiID0gMDtcbiAgICBpZiAoaC5sZW5ndGggPT0gNCkge1xuICAgICAgciA9ICcweCcgKyBoWzFdICsgaFsxXTtcbiAgICAgIGcgPSAnMHgnICsgaFsyXSArIGhbMl07XG4gICAgICBiID0gJzB4JyArIGhbM10gKyBoWzNdO1xuICAgIH0gZWxzZSBpZiAoaC5sZW5ndGggPT0gNykge1xuICAgICAgciA9ICcweCcgKyBoWzFdICsgaFsyXTtcbiAgICAgIGcgPSAnMHgnICsgaFszXSArIGhbNF07XG4gICAgICBiID0gJzB4JyArIGhbNV0gKyBoWzZdO1xuICAgIH1cbiAgICByZXR1cm4gW3BhcnNlSW50KHIpLCBwYXJzZUludChnKSwgcGFyc2VJbnQoYildO1xuICB9O1xuICByZXR1cm4gRGF0YVZpc3VhbGl6YXRpb247XG59KCk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xudmFyIE1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIC8vIE1lcmdlIHRoZSBnaXZlbiBvcHRpb25zIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgIHRoaXMucGFyYW1zID0gbWVyZ2UoTWFwLmRlZmF1bHRzLCBvcHRpb25zLCB0cnVlKTtcblxuICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiBtYXAgbmFtZSBkb2Vzbid0IG1hdGNoXG4gICAgLy8gdGhlIG1hcCB0aGF0IHdhcyBzZXQgaW4gbWFwIGZpbGVcbiAgICBpZiAoIU1hcC5tYXBzW3RoaXMucGFyYW1zLm1hcF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHQgdG8gdXNlIG1hcCB3aGljaCB3YXMgbm90IGxvYWRlZDogXCIgKyBvcHRpb25zLm1hcCk7XG4gICAgfVxuICAgIHRoaXMucmVnaW9ucyA9IHt9O1xuICAgIHRoaXMuc2NhbGUgPSAxO1xuICAgIHRoaXMudHJhbnNYID0gMDtcbiAgICB0aGlzLnRyYW5zWSA9IDA7XG4gICAgdGhpcy5fbWFwRGF0YSA9IE1hcC5tYXBzW3RoaXMucGFyYW1zLm1hcF07XG4gICAgdGhpcy5fbWFya2VycyA9IHt9O1xuICAgIHRoaXMuX2xpbmVzID0ge307XG4gICAgdGhpcy5fZGVmYXVsdFdpZHRoID0gdGhpcy5fbWFwRGF0YS53aWR0aDtcbiAgICB0aGlzLl9kZWZhdWx0SGVpZ2h0ID0gdGhpcy5fbWFwRGF0YS5oZWlnaHQ7XG4gICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgdGhpcy5fYmFzZVNjYWxlID0gMTtcbiAgICB0aGlzLl9iYXNlVHJhbnNYID0gMDtcbiAgICB0aGlzLl9iYXNlVHJhbnNZID0gMDtcblxuICAgIC8vIGBkb2N1bWVudGAgaXMgYWxyZWFkeSByZWFkeSwganVzdCBpbml0aWFsaXNlIG5vd1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2FpdCB1bnRpbCBgZG9jdW1lbnRgIGlzIHJlYWR5XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl9pbml0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdmFyIF9wcm90byA9IE1hcC5wcm90b3R5cGU7XG4gIF9wcm90by5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5wYXJhbXM7XG4gICAgdGhpcy5jb250YWluZXIgPSBnZXRFbGVtZW50KG9wdGlvbnMuc2VsZWN0b3IpO1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2p2bS1jb250YWluZXInKTtcblxuICAgIC8vIFRoZSBtYXAgY2FudmFzIGVsZW1lbnRcbiAgICB0aGlzLmNhbnZhcyA9IG5ldyBTVkdDYW52YXNFbGVtZW50KHRoaXMuY29udGFpbmVyKTtcblxuICAgIC8vIFNldCB0aGUgbWFwJ3MgYmFja2dyb3VuZCBjb2xvclxuICAgIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcblxuICAgIC8vIENyZWF0ZSByZWdpb25zXG4gICAgdGhpcy5fY3JlYXRlUmVnaW9ucygpO1xuXG4gICAgLy8gVXBkYXRlIHNpemVcbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcblxuICAgIC8vIENyZWF0ZSBsaW5lc1xuICAgIHRoaXMuX2NyZWF0ZUxpbmVzKG9wdGlvbnMubGluZXMgfHwge30sIG9wdGlvbnMubWFya2VycyB8fCB7fSk7XG5cbiAgICAvLyBDcmVhdGUgbWFya2Vyc1xuICAgIHRoaXMuX2NyZWF0ZU1hcmtlcnMob3B0aW9ucy5tYXJrZXJzKTtcblxuICAgIC8vIFBvc2l0aW9uIGxhYmVsc1xuICAgIHRoaXMuX3JlcG9zaXRpb25MYWJlbHMoKTtcblxuICAgIC8vIFNldHVwIHRoZSBjb250YWluZXIgZXZlbnRzXG4gICAgdGhpcy5fc2V0dXBDb250YWluZXJFdmVudHMoKTtcblxuICAgIC8vIFNldHVwIHJlZ2lvbnMvbWFya2VycyBldmVudHNcbiAgICB0aGlzLl9zZXR1cEVsZW1lbnRFdmVudHMoKTtcblxuICAgIC8vIENyZWF0ZSB6b29tIGJ1dHRvbnMgaWYgYHpvb21CdXR0b25zYCBpcyBwcmVzZW50ZWRcbiAgICBpZiAob3B0aW9ucy56b29tQnV0dG9ucykge1xuICAgICAgdGhpcy5fc2V0dXBab29tQnV0dG9ucygpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0b29saXBcbiAgICBpZiAob3B0aW9ucy5zaG93VG9vbHRpcCkge1xuICAgICAgdGhpcy5fdG9vbHRpcCA9IG5ldyBUb29sdGlwKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFNldCBzZWxlY3RlZCByZWdpb25zIGlmIGFueVxuICAgIGlmIChvcHRpb25zLnNlbGVjdGVkUmVnaW9ucykge1xuICAgICAgdGhpcy5fc2V0U2VsZWN0ZWQoJ3JlZ2lvbnMnLCBvcHRpb25zLnNlbGVjdGVkUmVnaW9ucyk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHNlbGVjdGVkIHJlZ2lvbnMgaWYgYW55XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ZWRNYXJrZXJzKSB7XG4gICAgICB0aGlzLl9zZXRTZWxlY3RlZCgnX21hcmtlcnMnLCBvcHRpb25zLnNlbGVjdGVkTWFya2Vycyk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGZvY3VzIG9uIGEgc3BjaWZpYyByZWdpb25cbiAgICBpZiAob3B0aW9ucy5mb2N1c09uKSB7XG4gICAgICB0aGlzLnNldEZvY3VzKG9wdGlvbnMuZm9jdXNPbik7XG4gICAgfVxuXG4gICAgLy8gRGF0YSB2aXN1YWxpemF0aW9uXG4gICAgaWYgKG9wdGlvbnMudmlzdWFsaXplRGF0YSkge1xuICAgICAgdGhpcy5kYXRhVmlzdWFsaXphdGlvbiA9IG5ldyBEYXRhVmlzdWFsaXphdGlvbihvcHRpb25zLnZpc3VhbGl6ZURhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIEJpbmQgdG91Y2ggZXZlbnRzIGlmIHRydWVcbiAgICBpZiAob3B0aW9ucy5iaW5kVG91Y2hFdmVudHMpIHtcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoKSB7XG4gICAgICAgIHRoaXMuX3NldHVwQ29udGFpbmVyVG91Y2hFdmVudHMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgc2VyaWVzIGlmIGFueVxuICAgIGlmIChvcHRpb25zLnNlcmllcykge1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5sZWdlbmRIb3Jpem9udGFsID0gY3JlYXRlRWxlbWVudCgnZGl2JywgJ2p2bS1zZXJpZXMtY29udGFpbmVyIGp2bS1zZXJpZXMtaCcpKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubGVnZW5kVmVydGljYWwgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCAnanZtLXNlcmllcy1jb250YWluZXIganZtLXNlcmllcy12JykpO1xuICAgICAgdGhpcy5fY3JlYXRlU2VyaWVzKCk7XG4gICAgfVxuXG4gICAgLy8gRmlyZSBsb2FkZWQgZXZlbnRcbiAgICB0aGlzLl9lbWl0KEV2ZW50cy5vbkxvYWRlZCwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICA7XG4gIF9wcm90by5zZXRCYWNrZ3JvdW5kQ29sb3IgPSBmdW5jdGlvbiBzZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3IpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgfVxuXG4gIC8vIFJlZ2lvbiBtZXRob2RzXG4gIDtcbiAgX3Byb3RvLmdldFNlbGVjdGVkUmVnaW9ucyA9IGZ1bmN0aW9uIGdldFNlbGVjdGVkUmVnaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWQoJ3JlZ2lvbnMnKTtcbiAgfTtcbiAgX3Byb3RvLmNsZWFyU2VsZWN0ZWRSZWdpb25zID0gZnVuY3Rpb24gY2xlYXJTZWxlY3RlZFJlZ2lvbnMocmVnaW9ucykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIGlmIChyZWdpb25zID09PSB2b2lkIDApIHtcbiAgICAgIHJlZ2lvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJlZ2lvbnMgPSB0aGlzLl9ub3JtYWxpemVSZWdpb25zKHJlZ2lvbnMpIHx8IHRoaXMuX2dldFNlbGVjdGVkKCdyZWdpb25zJyk7XG4gICAgcmVnaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF90aGlzMi5yZWdpb25zW2tleV0uZWxlbWVudC5zZWxlY3QoZmFsc2UpO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uc2V0U2VsZWN0ZWRSZWdpb25zID0gZnVuY3Rpb24gc2V0U2VsZWN0ZWRSZWdpb25zKHJlZ2lvbnMpIHtcbiAgICB0aGlzLmNsZWFyU2VsZWN0ZWRSZWdpb25zKCk7XG4gICAgdGhpcy5fc2V0U2VsZWN0ZWQoJ3JlZ2lvbnMnLCB0aGlzLl9ub3JtYWxpemVSZWdpb25zKHJlZ2lvbnMpKTtcbiAgfVxuXG4gIC8vIE1hcmtlcnMgbWV0aG9kc1xuICA7XG4gIF9wcm90by5nZXRTZWxlY3RlZE1hcmtlcnMgPSBmdW5jdGlvbiBnZXRTZWxlY3RlZE1hcmtlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkKCdfbWFya2VycycpO1xuICB9O1xuICBfcHJvdG8uY2xlYXJTZWxlY3RlZE1hcmtlcnMgPSBmdW5jdGlvbiBjbGVhclNlbGVjdGVkTWFya2VycygpIHtcbiAgICB0aGlzLl9jbGVhclNlbGVjdGVkKCdfbWFya2VycycpO1xuICB9O1xuICBfcHJvdG8uYWRkTWFya2VycyA9IGZ1bmN0aW9uIGFkZE1hcmtlcnMoY29uZmlnKSB7XG4gICAgY29uZmlnID0gQXJyYXkuaXNBcnJheShjb25maWcpID8gY29uZmlnIDogW2NvbmZpZ107XG4gICAgdGhpcy5fY3JlYXRlTWFya2Vycyhjb25maWcsIHRydWUpO1xuICB9O1xuICBfcHJvdG8ucmVtb3ZlTWFya2VycyA9IGZ1bmN0aW9uIHJlbW92ZU1hcmtlcnMobWFya2Vycykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIGlmICghbWFya2Vycykge1xuICAgICAgbWFya2VycyA9IE9iamVjdC5rZXlzKHRoaXMuX21hcmtlcnMpO1xuICAgIH1cbiAgICBtYXJrZXJzLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NXG4gICAgICBfdGhpczMuX21hcmtlcnNbaW5kZXhdLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAvLyBSZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSBtYXJrZXJzIG9iamVjdFxuICAgICAgZGVsZXRlIF90aGlzMy5fbWFya2Vyc1tpbmRleF07XG4gICAgfSk7XG4gIH07XG4gIF9wcm90by5hZGRMaW5lID0gZnVuY3Rpb24gYWRkTGluZShmcm9tLCB0bywgc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUgPT09IHZvaWQgMCkge1xuICAgICAgc3R5bGUgPSB7fTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKCdgYWRkTGluZWAgbWV0aG9kIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYGFkZExpbmVzYCBpbnN0ZWFkLicpO1xuICAgIHRoaXMuX2NyZWF0ZUxpbmVzKFt7XG4gICAgICBmcm9tOiBmcm9tLFxuICAgICAgdG86IHRvLFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfV0sIHRoaXMuX21hcmtlcnMsIHRydWUpO1xuICB9O1xuICBfcHJvdG8uYWRkTGluZXMgPSBmdW5jdGlvbiBhZGRMaW5lcyhjb25maWcpIHtcbiAgICB2YXIgdWlkcyA9IHRoaXMuX2dldExpbmVzQXNVaWRzKCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgIGNvbmZpZyA9IFtjb25maWddO1xuICAgIH1cbiAgICB0aGlzLl9jcmVhdGVMaW5lcyhjb25maWcuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICByZXR1cm4gISh1aWRzLmluZGV4T2YoZ2V0TGluZVVpZChsaW5lLmZyb20sIGxpbmUudG8pKSA+IC0xKTtcbiAgICB9KSwgdGhpcy5fbWFya2VycywgdHJ1ZSk7XG4gIH07XG4gIF9wcm90by5yZW1vdmVMaW5lcyA9IGZ1bmN0aW9uIHJlbW92ZUxpbmVzKGxpbmVzKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGluZXMpKSB7XG4gICAgICBsaW5lcyA9IGxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICByZXR1cm4gZ2V0TGluZVVpZChsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVzID0gdGhpcy5fZ2V0TGluZXNBc1VpZHMoKTtcbiAgICB9XG4gICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAodWlkKSB7XG4gICAgICBfdGhpczQuX2xpbmVzW3VpZF0uZGlzcG9zZSgpO1xuICAgICAgZGVsZXRlIF90aGlzNC5fbGluZXNbdWlkXTtcbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLnJlbW92ZUxpbmUgPSBmdW5jdGlvbiByZW1vdmVMaW5lKGZyb20sIHRvKSB7XG4gICAgY29uc29sZS53YXJuKCdgcmVtb3ZlTGluZWAgbWV0aG9kIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYHJlbW92ZUxpbmVzYCBpbnN0ZWFkLicpO1xuICAgIHZhciB1aWQgPSBnZXRMaW5lVWlkKGZyb20sIHRvKTtcbiAgICBpZiAodGhpcy5fbGluZXMuaGFzT3duUHJvcGVydHkodWlkKSkge1xuICAgICAgdGhpcy5fbGluZXNbdWlkXS5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuX2xpbmVzW3VpZF07XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzZXQgbWFwXG4gIDtcbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuc2VyaWVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VyaWVzW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zZXJpZXNba2V5XVtpXS5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5sZWdlbmRIb3Jpem9udGFsKSB7XG4gICAgICByZW1vdmVFbGVtZW50KHRoaXMubGVnZW5kSG9yaXpvbnRhbCk7XG4gICAgICB0aGlzLmxlZ2VuZEhvcml6b250YWwgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZWdlbmRWZXJ0aWNhbCkge1xuICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLmxlZ2VuZFZlcnRpY2FsKTtcbiAgICAgIHRoaXMubGVnZW5kVmVydGljYWwgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNjYWxlID0gdGhpcy5fYmFzZVNjYWxlO1xuICAgIHRoaXMudHJhbnNYID0gdGhpcy5fYmFzZVRyYW5zWDtcbiAgICB0aGlzLnRyYW5zWSA9IHRoaXMuX2Jhc2VUcmFuc1k7XG4gICAgdGhpcy5fYXBwbHlUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLmNsZWFyU2VsZWN0ZWRNYXJrZXJzKCk7XG4gICAgdGhpcy5jbGVhclNlbGVjdGVkUmVnaW9ucygpO1xuICAgIHRoaXMucmVtb3ZlTWFya2VycygpO1xuICB9XG5cbiAgLy8gRGVzdHJveSB0aGUgbWFwXG4gIDtcbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KGRlc3Ryb3lJbnN0YW5jZSkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgIGlmIChkZXN0cm95SW5zdGFuY2UgPT09IHZvaWQgMCkge1xuICAgICAgZGVzdHJveUluc3RhbmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGV2ZW50IHJlZ2lzdHJ5XG4gICAgRXZlbnRIYW5kbGVyLmZsdXNoKCk7XG5cbiAgICAvLyBSZW1vdmUgdG9vbHRpcCBmcm9tIERPTSBhbmQgbWVtb3J5XG4gICAgdGhpcy5fdG9vbHRpcC5kaXNwb3NlKCk7XG5cbiAgICAvLyBGaXJlIGRlc3Ryb3llZCBldmVudFxuICAgIHRoaXMuX2VtaXQoRXZlbnRzLm9uRGVzdHJveWVkKTtcblxuICAgIC8vIFJlbW92ZSByZWZlcmVuY2VzXG4gICAgaWYgKGRlc3Ryb3lJbnN0YW5jZSkge1xuICAgICAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVsZXRlIF90aGlzNVtrZXldO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbWV0aG9kIFtcIiArIG5hbWUgKyBcIl0gZG9lcyBhbHJlYWR5IGV4aXN0LCBwbGVhc2UgdXNlIGFub3RoZXIgbmFtZS5cIik7XG4gICAgfVxuICAgIE1hcC5wcm90b3R5cGVbbmFtZV0gPSBjYWxsYmFjaztcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgO1xuICBfcHJvdG8uX2VtaXQgPSBmdW5jdGlvbiBfZW1pdChldmVudE5hbWUsIGFyZ3MpIHtcbiAgICBmb3IgKHZhciBldmVudCBpbiBFdmVudHMpIHtcbiAgICAgIGlmIChFdmVudHNbZXZlbnRdID09PSBldmVudE5hbWUgJiYgdHlwZW9mIHRoaXMucGFyYW1zW2V2ZW50XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnBhcmFtc1tldmVudF0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHNlbGVjdGVkIG1hcmtlcnMvcmVnaW9uc1xuICA7XG4gIF9wcm90by5fZ2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiBfZ2V0U2VsZWN0ZWQodHlwZSkge1xuICAgIHZhciBzZWxlY3RlZCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzW3R5cGVdKSB7XG4gICAgICBpZiAodGhpc1t0eXBlXVtrZXldLmVsZW1lbnQuaXNTZWxlY3RlZCkge1xuICAgICAgICBzZWxlY3RlZC5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZDtcbiAgfTtcbiAgX3Byb3RvLl9zZXRTZWxlY3RlZCA9IGZ1bmN0aW9uIF9zZXRTZWxlY3RlZCh0eXBlLCBrZXlzKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChfdGhpczZbdHlwZV1ba2V5XSkge1xuICAgICAgICBfdGhpczZbdHlwZV1ba2V5XS5lbGVtZW50LnNlbGVjdCh0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX3Byb3RvLl9jbGVhclNlbGVjdGVkID0gZnVuY3Rpb24gX2NsZWFyU2VsZWN0ZWQodHlwZSkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgIHRoaXMuX2dldFNlbGVjdGVkKHR5cGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX3RoaXM3W3R5cGVdW2tleV0uZWxlbWVudC5zZWxlY3QoZmFsc2UpO1xuICAgIH0pO1xuICB9O1xuICBfcHJvdG8uX2dldExpbmVzQXNVaWRzID0gZnVuY3Rpb24gX2dldExpbmVzQXNVaWRzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9saW5lcyk7XG4gIH07XG4gIF9wcm90by5fbm9ybWFsaXplUmVnaW9ucyA9IGZ1bmN0aW9uIF9ub3JtYWxpemVSZWdpb25zKHJlZ2lvbnMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHJlZ2lvbnMgPT09ICdzdHJpbmcnID8gW3JlZ2lvbnNdIDogcmVnaW9ucztcbiAgfTtcbiAgcmV0dXJuIE1hcDtcbn0oKTtcbk1hcC5tYXBzID0ge307XG5NYXAuZGVmYXVsdHMgPSBEZWZhdWx0cztcbk9iamVjdC5hc3NpZ24oTWFwLnByb3RvdHlwZSwgY29yZSk7XG5cbi8qKlxuICoganNWZWN0b3JNYXBcbiAqIENvcHlyaWdodHMgKGMpIE11c3RhZmEgT21hciBodHRwczovL2dpdGh1Yi5jb20vdGhlbXVzdGFmYW9tYXJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbnZhciBqc1ZlY3Rvck1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGpzVmVjdG9yTWFwKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5zZWxlY3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWxlY3RvciBpcyBub3QgZ2l2ZW4uJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWFwKG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gUHVibGljXG4gIGpzVmVjdG9yTWFwLmFkZE1hcCA9IGZ1bmN0aW9uIGFkZE1hcChuYW1lLCBtYXApIHtcbiAgICBNYXAubWFwc1tuYW1lXSA9IG1hcDtcbiAgfTtcbiAgcmV0dXJuIGpzVmVjdG9yTWFwO1xufSgpO1xudmFyIGluZGV4ID0gd2luZG93LmpzVmVjdG9yTWFwID0ganNWZWN0b3JNYXA7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsvectormap/dist/jsvectormap.esm.js\n");

/***/ })

};
;